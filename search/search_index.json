{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p></p> <p></p> <p> <p></p> <p></p> <p> <p></p> <p></p> <p> <p></p> <p></p>"},{"location":"#reating-2d-tower-defense-game-with-pixijs","title":"\u0421reating 2D Tower Defense game with PixiJS","text":"<p>Read</p>"},{"location":"#creating-a-2d-infinite-runner-game-with-pixijs","title":"Creating a 2D infinite runner game with PixiJS","text":"<p>Read</p>"},{"location":"#reating-match3-game-with-pixijs","title":"\u0421reating Match3 game with PixiJS","text":"<p>Read</p>"},{"location":"#reating-pixijs-project-template","title":"\u0421reating PixiJS project template","text":"<p>Read</p>"},{"location":"match3/","title":"\u0421reating Match3 game with PixiJS","text":"<p>In this article, we will create a match3 game using PIXI.</p>"},{"location":"match3/#video-version","title":"Video version","text":""},{"location":"match3/#step-by-step-guide-on-udemy","title":"Step-by-step guide on Udemy","text":"<ul> <li>https://www.udemy.com/course/pixicourse/</li> </ul>"},{"location":"match3/#additional-materials","title":"Additional materials","text":"<ul> <li>Complete source code</li> <li>Preview demo</li> </ul> <p>Before starting the development, we need to perform 2 steps:</p> <p> Download our PIXI project template. You can start working on the game right now or check out the tutorial on how to create a PIXI project template.</p> <p> Download the assets pack for our game. Assets provided by the great website kenney.nl</p>"},{"location":"match3/#1-creating-the-tiles-board","title":"1. Creating the tiles board","text":"<p>Let's set the first task to create the board with tiles.</p>"},{"location":"match3/#11-creating-a-single-field","title":"1.1. Creating a single field","text":"<p>The first step is to create a board field class and render a single field sprite on the screen.</p> <p>Create the <code>game/Field.js</code> class: <pre><code>import { App } from \"../system/App\";\n\nexport class Field {\n    constructor(row, col) {\n        this.row = row;\n        this.col = col;\n\n        this.sprite = App.sprite(\"field\");\n        this.sprite.x = this.position.x;\n        this.sprite.y = this.position.y;\n        this.sprite.anchor.set(0.5);\n    }\n\n    get position() {\n        return {\n            x: this.col * this.sprite.width,\n            y: this.row * this.sprite.height\n        };\n    }\n}\n</code></pre></p> <p>A field is located in a certain column and in a certain row on the board. </p> <p>Info</p> <ul> <li>The <code>row</code> and <code>col</code> properties of the <code>Field</code> class define the row and column.</li> <li>The <code>position</code> getter determines the position of the field on the screen, depending on the position on the board and taking into account the size of the field sprite.</li> </ul> <p>And now we can render a single field on the screen in the <code>Game</code> class:</p> <pre><code>import { Field } from \"./Field\";\n// ...    \nexport class Game {\n    constructor() {\n        // ...\n        const field = new Field(1, 1);\n        this.container.addChild(field.sprite);\n    }\n}\n</code></pre>"},{"location":"match3/#12-creating-a-fields-grid","title":"1.2. Creating a fields grid","text":"<p>We have a class for the board field and now we can create the board itself, consisting of a number of fields. Let's create a class <code>src/scripts/game/Board.js</code>:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\nimport { Field } from \"./Field\";\n\nexport class Board {\n    constructor() {\n        this.container = new PIXI.Container();\n        this.fields = [];\n        this.rows = App.config.board.rows;\n        this.cols = App.config.board.cols;\n        this.create();\n    }\n\n    create() {\n    }\n}\n</code></pre> <p>We will add all elements of the board (fields and tiles) to the board container. And the board container is then added to the scene container.</p> <p>The board consists of a grid of fields. Let's set all the created fields to the <code>this.fields</code> property.</p> <p>The number of rows and columns should be configurable. Therefore, let's add these settings to the global project config:</p> <pre><code>// ...\nexport const Config = {\n    // ...\n    board: {\n        rows: 6,\n        cols: 6\n    }\n};\n</code></pre> <p>To create a board, we need to place its fields on a grid of a given size. That is, create field sprites in each column and each row of the board. Let's do this in the <code>create</code> method:</p> <p><pre><code>export class Board {\n    // ...\n    create() {\n        this.createFields();\n    }\n\n    createFields() {\n        for (let row = 0; row &lt; this.rows; row++) {\n            for (let col = 0; col &lt; this.cols; col++) {\n                this.createField(row, col);\n            }\n        }\n    }\n    createField(row, col) {\n        const field = new Field(row, col);\n        this.fields.push(field);\n        this.container.addChild(field.sprite);\n    }\n}\n</code></pre> Let's bring the board to the stage in the <code>Game</code> class: <pre><code>// ...\nexport class Game {\n    constructor() {\n        // ...\n        this.board = new Board();\n        this.container.addChild(this.board.container);\n    }\n// ...\n}\n</code></pre></p> <p>Now the board is located in the upper left corner. Let's fix this by aligning its position to the center of the screen. We can get the size of the board's field by taking the first element from the generated fields array and reading the width of its sprite: <code>this.fields[0].sprite.width;</code> Knowing the size of one field, we can calculate the size of the entire board by multiplying the number of rows and columns by the size of the field:</p> <p><pre><code>        this.width = this.cols * this.fieldSize;\n        this.height = this.rows * this.fieldSize;\n</code></pre> Knowing the size of the board and the size of the screen, we can make the right padding for the board container. Subtract the size of the board from the size of the screen and the resulting remaining space will take up 2 indents to the left and right of the board: <pre><code>export class Board {\n    constructor() {\n        // ...\n        this.ajustPosition();\n    }\n    // ...\n    ajustPosition() {\n        this.fieldSize = this.fields[0].sprite.width;\n        this.width = this.cols * this.fieldSize;\n        this.height = this.rows * this.fieldSize;\n        this.container.x = (window.innerWidth - this.width) / 2 + this.fieldSize / 2;\n        this.container.y = (window.innerHeight - this.height) / 2 + this.fieldSize / 2;\n    }\n}\n</code></pre></p>"},{"location":"match3/#13-creating-a-single-tile","title":"1.3. Creating a single tile","text":"<p>We have the board fields ready, and now we can create matching tiles in them. As in the case with the fields creation, we will start by creating a class for a single tile.</p> <p>As we can see in the assets, all tile names refer to their colors. To create a sprite, we need to specify the color we want to give to that tile. We pass the name of the color as a parameter in the constructor and create the corresponding sprite. Create a file <code>src/scripts/games/Tile.js</code>:</p> <pre><code>import { App } from \"../system/App\";\n\nexport class Tile {\n    constructor(color) {\n        this.color = color;\n        this.sprite = App.sprite(this.color);\n        this.sprite.anchor.set(0.5);\n    }\n\n    setPosition(position) {\n        this.sprite.x = position.x;\n        this.sprite.y = position.y;\n    }\n}\n</code></pre> <p>We also implement the <code>setPosition</code> method, which will set the sprite to the correct position. Let's add a single tile in the <code>Board</code> class:</p> <pre><code>// ...\nimport { Tile } from \"./Tile\";\n\nexport class Board {\n// ...\n    create() {\n        this.createFields();\n        this.createTiles();\n    }\n\n    createTiles() {\n        const tile = new Tile(\"green\");\n        this.container.addChild(tile.sprite);\n    }\n// ...\n</code></pre>"},{"location":"match3/#14-create-a-tile-in-each-field","title":"1.4. Create a tile in each field","text":"<p>Now we can create a tile in each field of the board. To do this, we can loop through the array of all fields and set our own tile in each field:</p> <pre><code>    create() {\n        this.createFields();\n        this.createTiles();\n    }\n\n    createTiles() {\n        this.fields.forEach(field =&gt; this.createTile(field));\n    }\n\n    createTile(field) {\n        const tile = new Tile(\"green\");\n        field.setTile(tile);\n        this.container.addChild(tile.sprite);\n    }\n</code></pre> <p>Set a tile in each field means to place the tile in the same position on the screen as the given field. Let's implement the setTile method in the <code>Field</code> class:</p> <p><pre><code>    setTile(tile) {\n        this.tile = tile;\n        tile.field = this;\n        tile.setPosition(this.position);\n    }\n}\n</code></pre> It remains to make sure that each field has a tile with a random color. To do this, we will create a factory that will generate a random tile. Let's create the <code>src/scripts/game/TileFactory.js</code> class:</p> <pre><code>import { App } from \"../system/App\";\nimport { Tools } from \"../system/Tools\";\nimport { Tile } from \"./Tile\";\n\n\nexport class TileFactory {\n    static generate() {\n        const color = App.config.tilesColors[Tools.randomNumber(0, App.config.tilesColors.length - 1)];\n        return new Tile(color);\n    }\n}\n</code></pre> <p>Add the colors config to the project global config in <code>src/scripts/game/Config.js</code>:</p> <p><pre><code>export const Config = {\n    // ...\n    tilesColors: ['blue', 'green', 'orange', 'red', 'pink', 'yellow'],\n};\n</code></pre> And add a method that returns a random integer to our special helpers class <code>src/scripts/system/Tools.js</code>:</p> <pre><code>export class Tools {\n    // ...\n    static randomNumber(min, max) {\n        if (!max) {\n            max = min;\n            min = 0;\n        }\n\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n}\n</code></pre> <p>And now in the <code>Board</code> class we create a tile using the factory:</p> <pre><code>    createTile(field) {\n        const tile = TileFactory.generate();\n        // ...\n    }\n</code></pre>"},{"location":"match3/#2-moving-tiles","title":"2. Moving tiles","text":"<p>We start developing the functionality for moving tiles.</p>"},{"location":"match3/#21-selecting-a-tile-to-move","title":"2.1 Selecting a tile to move","text":"<p>We need to click on a tile to select it. This means tiles must be interactive. Let's add interactivity when creating tiles in the <code>Board</code> class:</p> <p><pre><code>    createTile(field) {\n        // ...\n        tile.sprite.interactive = true;\n        tile.sprite.on(\"pointerdown\", () =&gt; {\n            this.container.emit('tile-touch-start', tile);\n        });\n    }\n</code></pre> Let's fire the <code>tile-touch-start</code> event using the capabilities of the <code>PIXI.Container</code> class. And then track and handle this event in the <code>Game</code> class:</p> <pre><code>// ...\nexport class Game {\n    constructor() {\n        // ...\n        this.board.container.on('tile-touch-start', this.onTileClick.bind(this));\n    }\n// ...\n</code></pre> <p>Let's run the <code>onTileClick</code> method when the <code>tile-touch-start</code> event fires. In this method, we will handle all three possible scenarios:</p> <p> select a new tile to move if no other tile has been selected</p> <p> swap tiles if another tile has already been selected and it is next to the current one</p> <p> select a new tile if another tile has already been selected, but it is not next to the current one</p> <p>Right now we are implementing the first point. Now we are implementing the first point. When choosing a new tile, we need to do 2 things:</p> <ol> <li>remember the selected tile</li> <li>visually highlight the selected field</li> </ol> <pre><code>export class Game {\n    onTileClick(tile) {\n        if (this.selectedTile) {\n            // select new tile or make swap\n        } else {\n            this.selectTile(tile);\n        }\n    }\n\n    selectTile(tile) {\n        this.selectedTile = tile;\n        this.selectedTile.field.select();\n    }\n</code></pre> <p>We can highlight the field with the selected tile by showing an additional border in this field. Let's implement the code in the <code>Field</code> class:</p> <pre><code>export class Field {\n    constructor(row, col) {\n        // ...\n        this.selected = App.sprite(\"field-selected\");\n        this.sprite.addChild(this.selected);\n        this.selected.visible = false;\n        this.selected.anchor.set(0.5);\n\n    }\n\n    unselect() {\n        this.selected.visible = false;\n    }\n\n    select() {\n        this.selected.visible = true;\n    }\n</code></pre>"},{"location":"match3/#22-swapping-tiles","title":"2.2 Swapping tiles","text":"<p>In the <code>onTileClick</code> method of the <code>Game</code> class, add <code>swap</code> method call, which implements the movement of tiles:</p> <p><pre><code>    onTileClick(tile) {\n        if (this.selectedTile) {\n            this.swap(this.selectedTile, tile);\n        } else {\n            this.selectTile(tile);\n        }\n    }\n</code></pre> Let's define what actions we need to move tiles:</p> <p> Reset fields in moved tiles</p> <p> Reset tiles in the board's fields</p> <p> Place the moved tiles in the positions of the new fields on the screen</p> <p>We will create tweens animation using gsap for tiles movement. It's also worth locking the board by setting an additional flag to prevent interactivity while the animation is running.</p> <p>Let's implement these actions in code: <pre><code>    swap(selectedTile, tile) {\n        this.disabled = true;        // lock the board to prevent tiles from moving again while the animation is already running\n        this.clearSelection();      // hide the \"field-selected\" frame from the field of the selectedTile object\n        selectedTile.sprite.zIndex = 2; // place the selectedTile sprite one layer higher than the tile sprite\n\n        selectedTile.moveTo(tile.field.position, 0.2); // move selectedTile to tile position\n        // move tile to electedTile position\n        tile.moveTo(selectedTile.field.position, 0.2).then(() =&gt; {\n            // after motion animations complete:\n            // change the values of the field properties in the tile objects\n            // change the values of the tile properties in the field objects\n            this.board.swap(selectedTile, tile);\n            this.disabled = false; // unlock the board\n        });\n    }\n</code></pre></p> <p>Let's reset the selection in the field in <code>clearSelection</code> method: <pre><code>    clearSelection() {\n        if (this.selectedTile) {\n            this.selectedTile.field.unselect();\n            this.selectedTile = null;\n        }\n    }\n</code></pre> Let's implement the <code>moveTo</code> method in the <code>Tile</code> class using the <code>gsap</code> tween animation:</p> <pre><code>    moveTo(position, duration) {\n        return new Promise(resolve =&gt; {\n            gsap.to(this.sprite, {\n                duration,\n                pixi: {\n                    x: position.x,\n                    y: position.y\n                },\n                onComplete: () =&gt; {\n                    resolve()\n                }\n            });\n        });\n    }\n</code></pre> <p>Let's add the <code>swap</code> method in the <code>Board</code> class, in which we will change the properties values in the moved objects:</p> <pre><code>    swap(tile1, tile2) {\n        const tile1Field = tile1.field;\n        const tile2Field = tile2.field;\n\n        tile1Field.tile = tile2;\n        tile2.field = tile1Field;\n\n        tile2Field.tile = tile1;\n        tile1.field = tile2Field;\n    }\n</code></pre> <p>Now, when moving tiles, we can swap not only neighboring tiles, but any tiles on the board. But only neighboring tiles should be swapped. And if the player has chosen a non-neighboring tile, then we just need to completely clear the first selection and select the new tile.</p> <p>Let's update the condition in the <code>onTileClick</code> method in the <code>Game</code> class:</p> <pre><code>    onTileClick(tile) {\n        if (this.disabled) {\n            return;\n        }\n\n        if (this.selectedTile) {\n            if (!this.selectedTile.isNeighbour(tile)) {\n                this.clearSelection(tile);\n                this.selectTile(tile);\n            } else {\n                this.swap(this.selectedTile, tile);\n            }\n        } else {\n            this.selectTile(tile);\n        }\n    }\n</code></pre> <p>Note</p> <p>As you can see, we also added a check for the <code>disabled</code> flag, which we set in the last paragraph. Thus, we block the functionality of the <code>onTileClick</code> method while the tiles are moving on the board, in order to avoid possible bugs.</p> <p>Let's implement the <code>isNeighbour</code> method in the <code>Tile</code> class. A neighbor is a tile located either in an adjacent column or in an adjacent row. This means that the difference between either rows or columns of the checked and current tile modulo must be equal to one:</p> <pre><code>    isNeighbour(tile) {\n        return Math.abs(this.field.row - tile.field.row) + Math.abs(this.field.col - tile.field.col) === 1\n    }\n</code></pre>"},{"location":"match3/#3-search-for-combinations","title":"3. Search for combinations","text":"<p>After swapping tiles, the board must be checked for combinations.</p> <p>Note</p> <p>A combination is considered to be the collection of 3, 4 and 5 identical tiles in a row.</p> <p>To check for all these combinations, it is enough to compare each tile on the board with the next two tiles in a row and the next two tiles in a column.</p> <p>Let's add the comparison rules to the game config <code>Config.js</code>:</p> <p><pre><code>export const Config = {\n    // ...\n    combinationRules: [[\n        {col: 1, row: 0}, {col: 2, row: 0},\n    ], [\n        {col: 0, row: 1}, {col: 0, row: 2},\n    ]]\n};\n</code></pre> We have added 2 validation rules that show exactly which fields on the board should have the same tiles in relation to the field being checked. That is, for each checked field on the board, it is necessary to check the match of the field in the next two columns, as well as in the next two rows.</p> <p>We implement the <code>CombinationManager</code> class:</p> <pre><code>import { App } from \"../system/App\";\n\nexport class CombinationManager {\n    constructor(board) {\n        this.board = board;\n    }\n\n    getMatches() {\n        let result = [];\n\n        this.board.fields.forEach(checkingField =&gt; {\n            App.config.combinationRules.forEach(rule =&gt; {\n                let matches = [checkingField.tile];\n\n                rule.forEach(position =&gt; {\n                    const row = checkingField.row + position.row;\n                    const col = checkingField.col + position.col;\n                    const comparingField = this.board.getField(row, col);\n                    if (comparingField &amp;&amp; comparingField.tile.color === checkingField.tile.color) {\n                        matches.push(comparingField.tile);\n                    }\n                });\n\n                if (matches.length === rule.length + 1) {\n                    result.push(matches);\n                }\n            });\n        });\n\n        return result;\n    }\n}\n</code></pre> <p>Let's implement the <code>getField</code> method in the <code>Board</code> class:</p> <pre><code>    getField(row, col) {\n        return this.fields.find(field =&gt; field.row === row &amp;&amp; field.col === col);\n    }\n</code></pre> <p>And call its method in the <code>Game</code> class:</p> <pre><code>import { CombinationManager } from \"./CombinationManager\";\n\nexport class Game {\n    constructor() {\n        // ...\n        this.combinationManager = new CombinationManager(this.board);\n    }\n\n    swap(selectedTile, tile) {\n        // ...\n        tile.moveTo(selectedTile.field.position, 0.2).then(() =&gt; {\n            this.board.swap(selectedTile, tile);\n            const matches = this.combinationManager.getMatches();\n            this.disabled = false;\n        });\n    }\n}\n</code></pre>"},{"location":"match3/#4-processing-combinations","title":"4. Processing combinations","text":""},{"location":"match3/#41-removing-tiles","title":"4.1 Removing tiles","text":"<p>First of all, we will remove all the tiles in the collected combinations:</p> <pre><code>export class Game {\n// ...\n    swap(selectedTile, tile) {\n        // ...\n            const matches = this.combinationManager.getMatches();\n            if (matches.length) {\n                this.processMatches(matches);\n            }\n        });\n    }\n\n    processMatches(matches) {\n        this.removeMatches(matches);\n    }\n\n    removeMatches(matches) {\n        matches.forEach(match =&gt; {\n            match.forEach(tile =&gt; {\n                tile.remove();\n            });\n        });\n    }\n}\n</code></pre> <p>Let's implement the <code>remove</code> method in the <code>Tile</code> class:</p> <p><pre><code>    remove() {\n        if (!this.sprite) {\n            return;\n        }\n        this.sprite.destroy();\n        this.sprite = null;\n\n        if (this.field) {\n            this.field.tile = null;\n            this.field = null;\n        }\n    }\n</code></pre> If the object no longer has a sprite, then it has already been deleted. Otherwise, we delete the sprite and the reference to the field. At the field itself, we also remove the reference to the current tile.</p>"},{"location":"match3/#42-fall-of-the-remaining-tiles","title":"4.2 Fall of the remaining tiles","text":"<p>After the combination is triggered and the collected tiles are removed, it is necessary to drop the remaining tiles on the board. Add <code>processFallDown</code> method call in <code>processMatches</code>:</p> <pre><code>    processMatches(matches) {\n        this.removeMatches(matches);\n        this.processFallDown();\n    }\n</code></pre> <p>Starting from the bottom row of the board, check each field for a tile. If the field is empty, we will shift down the column all the tiles that are above it:</p> <pre><code>    processFallDown() {\n        return new Promise(resolve =&gt; {\n            let completed = 0;\n            let started = 0;\n\n            // check all fields of the board, starting from the bottom row\n            for (let row = this.board.rows - 1; row &gt;= 0; row--) {\n                for (let col = this.board.cols - 1; col &gt;= 0; col--) {\n                    const field = this.board.getField(row, col);\n\n                    // if there is no tile in the field\n                    if (!field.tile) {\n                        ++started;\n\n                        // shift all tiles that are in the same column in all rows above\n                        this.fallDownTo(field).then(() =&gt; {\n                            ++completed;\n                            if (completed &gt;= started) {\n                                resolve();\n                            }\n                        });\n                    }\n                }\n            }\n        });\n    }\n</code></pre> <p>We implement moving tiles down the column in the <code>fallDownTo</code> method:</p> <pre><code>    fallDownTo(emptyField) {\n        // checking all board fields in the found empty field column, but in all higher rows\n        for (let row = emptyField.row - 1; row &gt;= 0; row--) {\n            let fallingField = this.board.getField(row, emptyField.col);\n\n            // find the first field with a tile\n            if (fallingField.tile) {\n                // the first found tile will be placed in the current empty field\n                const fallingTile = fallingField.tile;\n                fallingTile.field = emptyField;\n                emptyField.tile = fallingTile;\n                fallingField.tile = null;\n                // run the tile move method and stop searching a tile for that empty field\n                return fallingTile.fallDownTo(emptyField.position);\n            }\n        }\n\n        return Promise.resolve();\n    }\n</code></pre> <p>Let's add the <code>fallDownTo</code> method to the <code>Tile</code> class:</p> <pre><code>    fallDownTo(position, delay) {\n        return this.moveTo(position, 0.5, delay, \"bounce.out\");\n    }\n</code></pre>"},{"location":"match3/#43-adding-and-dropping-new-tiles","title":"4.3 Adding and dropping new tiles","text":"<p>After the completion of the fall of the remaining tiles, we need to create new tiles on top of the board so that they fall into the resulting empty fields:</p> <pre><code>    processMatches(matches) {\n        this.removeMatches(matches);\n        this.processFallDown()\n            .then(() =&gt; this.addTiles())\n\n    }\n</code></pre> <p>To perform the creation and dropping of new tiles, we need to get all the fields on the board that have no tiles left. For each empty field, create a new tile, place it higher than the first row of the board, and start the motion animation on the given empty field:</p> <pre><code>    addTiles() {\n        return new Promise(resolve =&gt; {\n            // get all fields that don't have tiles\n            const fields = this.board.fields.filter(field =&gt; field.tile === null);\n            let total = fields.length;\n            let completed = 0;\n\n            // for each empty field\n            fields.forEach(field =&gt; {\n                // create a new tile\n                const tile = this.board.createTile(field);\n                // put it above the board\n                tile.sprite.y = -500;\n                const delay = Math.random() * 2 / 10 + 0.3 / (field.row + 1);\n                // start the movement of the tile in the given empty field with the given delay\n                tile.fallDownTo(field.position, delay).then(() =&gt; {\n                    ++completed;\n                    if (completed &gt;= total) {\n                        resolve();\n                    }\n                });\n            });\n        });\n    }\n</code></pre>"},{"location":"match3/#44-checking-for-combinations-after-tiles-falling","title":"4.4 Checking for combinations after tiles falling","text":"<p>After the completion of falling new tiles, combinations may appear on the board again.</p> <p>If there are new combinations, it is also necessary to process them, that is, collect the combination, make a tiles fall and create new tiles. For all these actions, we have already developed functionality in the <code>processMatches</code> method. We will call it recursively until there are no combinations left on the board after the next falling of new tiles:</p> <pre><code>    processMatches(matches) {\n        this.removeMatches(matches);\n        this.processFallDown()\n            .then(() =&gt; this.addTiles())\n            .then(() =&gt; this.onFallDownOver());\n    }\n\n    onFallDownOver() {\n        const matches = this.combinationManager.getMatches();\n\n        if (matches.length) {\n            this.processMatches(matches)\n        } else {\n            this.disabled = false;\n        }\n    }\n</code></pre>"},{"location":"match3/#5-collect-combinations-at-the-start","title":"5. Collect combinations at the start","text":"<p>Combinations can appear be not only after moving two tiles, but also during the initial placement of tiles after creating the board. Such combinations must be automatically processed without falling animation and replaced with other tiles before showing the starting board to the player.</p> <p>We already have the functionality needed to handle starting combinations:</p> <p> Find all combinations on the board using <code>combinationManager</code>.</p> <p>  Remove all founded matches</p> <p>  Create new tiles in empty fields</p> <p>  If combinations appear after adding new tiles, then repeat. Otherwise, let's start the game.</p> <pre><code>// ...\nexport class Game {\n    constructor() {\n        // ...\n        this.removeStartMatches();\n    }\n\n    removeStartMatches() {\n        let matches = this.combinationManager.getMatches(); // find combinations to collect\n\n        while(matches.length) { // as long as there are combinations\n            this.removeMatches(matches); // remove tiles in combinations\n\n            const fields = this.board.fields.filter(field =&gt; field.tile === null); // find empty fields\n\n            fields.forEach(field =&gt; { // in each empty field\n                this.board.createTile(field); // create a new random tile\n            });\n\n            matches = this.combinationManager.getMatches(); // looking for combinations again after adding new tiles\n        }\n    }\n}\n</code></pre>"},{"location":"match3/#6-reverse-swap","title":"6. Reverse swap","text":"<p>If, after the swap, no combination was formed on the board to collect, it is necessary to perform a reverse swap of tiles. To move tiles on the board, we have already implemented the <code>swap</code> method. We can modify it to perform a reverse move if no combinations are found after the main move. Add the <code>reverse</code> flag as the third parameter to the <code>swap</code> method:</p> <pre><code>// ...\nexport class Game {\n// ...\n\n    swap(selectedTile, tile, reverse) {\n        this.disabled = true;\n        selectedTile.sprite.zIndex = 2;\n\n        selectedTile.moveTo(tile.field.position, 0.2);\n\n        this.clearSelection();\n\n        tile.moveTo(selectedTile.field.position, 0.2).then(() =&gt; {\n            this.board.swap(selectedTile, tile);\n\n            // after the swap, check if it was the main swap or reverse\n            if (!reverse) {\n                // if this is the main swap, then we are looking for combinations\n                const matches = this.combinationManager.getMatches();\n                if (matches.length) {\n                    // if there are combinations, then process them\n                    this.processMatches(matches);\n                } else {\n                    // if there are no combinations after the main swap, then perform a reverse swap by running the same method, but with the reverse parameter\n                    this.swap(tile, selectedTile, true);\n                }\n            } else {\n                // in this condition, by the reverse flag, we understand that the swap was reversed, so there is no need to look for combinations.\n                // all you need to do is unlock the board, because here the movement is already completed and there are no other animations\n                this.disabled = false;\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"pixi_project_template/","title":"\u0421reating PixiJS project template","text":"<p>In this article, our goal is to develop a simple project template that we will use as a foundation for all our future games. You can check the final template code in GitHub.</p>"},{"location":"pixi_project_template/#video-version","title":"Video version","text":""},{"location":"pixi_project_template/#step-by-step-guide-on-udemy","title":"Step-by-step guide on Udemy","text":"<ul> <li>https://www.udemy.com/course/pixicourse/</li> </ul>"},{"location":"pixi_project_template/#template-functionality","title":"Template functionality:","text":"<ul> <li>Application creation and launch</li> <li>Resource loading and rendering</li> <li>Management of scenes, states, animations, sounds and screen</li> </ul>"},{"location":"pixi_project_template/#1-creating-the-structure","title":"1. Creating the structure","text":"<p>Let's take an empty project structure from the initial branch and examine it.</p>"},{"location":"pixi_project_template/#11-document-template","title":"1.1 Document template","text":"index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n  &lt;/head&gt;\n  &lt;style&gt;\n    body {\n        background-color: #000;\n        padding: 0;\n        margin: 0;\n        width: 100%;\n        height: 100%;\n    }\n    canvas {\n        position:absolute;\n        top:50%;\n        left:50%;\n        transform: translate(-50%, -50%);\n        -o-transform: translate(-50%, -50%);\n        -ms-transform: translate(-50%, -50%);\n        -moz-transform: translate(-50%, -50%);\n        -webkit-transform: translate(-50%, -50%);\n    }\n  &lt;/style&gt;\n  &lt;body&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The HTML template will contain the final JavaScript code after the game is built. Let\u2019s style the canvas element and leave the <code>body</code> tag empty.</p>"},{"location":"pixi_project_template/#12-project-dependencies","title":"1.2 Project dependencies.","text":"package.json <pre><code>{\n  \"name\": \"match3\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"webpack --config webpack/prod.js \",\n    \"start\": \"webpack-dev-server --config webpack/base.js --open\"\n  },\n  \"dependencies\": {\n    \"gsap\": \"^3.10.4\",\n    \"pixi.js\": \"^6.5.1\"\n  },\n  \"devDependencies\": {\n    \"babel-loader\": \"^8.2.5\",\n    \"clean-webpack-plugin\": \"^4.0.0\",\n    \"file-loader\": \"^6.2.0\",\n    \"html-webpack-plugin\": \"^5.5.0\",\n    \"webpack-cli\": \"^4.10.0\",\n    \"webpack-dev-server\": \"^4.9.3\",\n    \"webpack-merge\": \"^5.8.0\"\n  }\n}\n</code></pre> <p>Config contains project settings and dependencies. Main dependencies are:</p> <ul> <li>gsap for animations</li> <li>pixi for rendering</li> <li>webpack and babel for build</li> </ul>"},{"location":"pixi_project_template/#13-project-structure","title":"1.3 Project structure","text":"<ul> <li><code>webpack/</code> - build scripts</li> <li><code>src/scripts/system/</code> - common system code, the same for all games</li> <li><code>src/scripts/game/</code> - code of the game itself, unique for each project</li> <li><code>src/sounds/</code> - audio assets</li> <li><code>src/sprites/</code> - images assets</li> </ul>"},{"location":"pixi_project_template/#14-commands","title":"1.4 Commands","text":"<p>First we need to install dependencies from <code>package.json</code></p> <pre><code>npm i\n</code></pre> <p>As you can see in the scripts block in <code>package.json</code>, we have 2 ways to run webpack: build and start.</p> <pre><code>npm start\n</code></pre> <p>This command creates the build with the developer environment and automatically run the project in the browser using dev-server.</p> <pre><code>npm run build\n</code></pre> <p>This command creates the build for production and save the created build's files in the <code>dist/</code> folder.</p> <p>This folder is created automatically and cleared every time we run the command, so be careful not to save files in this folder.</p>"},{"location":"pixi_project_template/#2-creating-the-canvas-element","title":"2. Creating the canvas element","text":"<p>Create a file <code>src/scripts/system/App.js</code>. This is the main class of the application. Let's implement the <code>run</code> method, which will start the game.</p> <pre><code>import * as PIXI from \"pixi.js\";\n\nclass Application {\n    run(config) {\n        this.config = config;\n        this.app = new PIXI.Application({resizeTo: window});\n        document.body.appendChild(this.app.view);\n    }\n}\n\nexport const App = new Application();\n</code></pre> <p>Here we import the <code>PIXI</code> library and create a <code>PIXI</code> application. The <code>view</code> property of the <code>this.app</code> object is just the HTML <code>canvas</code> element that we add to the DOM structure of our html template.</p> <p>In addition, we make this class a singleton by creating an instance of the class and exporting the created object, not the class itself.</p> <p>So wherever in the application we import from this file, we will always get the same <code>App</code> object. This way using the global <code>App</code> object we can get access to all the necessary classes for managing the game: screen manager, sound manager, scene manager, and so on.</p> <p>Create an entry point <code>src/scripts/index.js</code> and run the application:</p> <pre><code>import { App } from \"./system/App\";\nApp.run();\n</code></pre>"},{"location":"pixi_project_template/#3-creating-the-loader","title":"3. Creating the loader","text":"<p>Let's start with the loader interface that we want to implement. <pre><code>class Application {\n   run(config) {\n        // \u2026\n        this.loader = new Loader(this.app.loader, this.config);\n        this.loader.preload().then(() =&gt; this.start());\n    }\n    start() {\n    }\n</code></pre></p> <p>To load resources, <code>PIXI</code> provides us with the <code>PIXI.Loader</code> class. We can get it from the <code>app</code> property.</p> <p>We pass it as the first parameter to the constructor of our custom <code>Loader</code> class. And the second parameter is a list of resources to download.</p> <p>Create class <code>src/scripts/system/Loader.js</code>:</p> <p><pre><code>export class Loader {\n    constructor(loader, config) {\n        this.loader = loader;\n        this.config = config;\n        this.resources = {};\n    }\n    preload() {\n        return Promise.resolve();\n    }\n}\n</code></pre> We will add all the loaded resources objects in the <code>resources</code> property which is empty by default.</p> <p>Since the list of resources will be unique for each game, we need to define the resource config separately from the general code, that is, outside the <code>system</code> folder.</p> <p>Let's create a <code>game/Config.js</code> file. Here we create the <code>Config</code> object, which will be unique for each specific game:</p> <pre><code>import { Tools } from \"../system/Tools\";\n\nexport const Config = {\n    loader: Tools.massiveRequire(require[\"context\"]('./../../sprites/', true, /\\.(mp3|png|jpe?g)$/))\n};\n</code></pre> <p>Let's set the list of resources to load in the <code>loader</code> property.</p> <p>To automatically get the entire list of resources to load from a given folder, we use the capabilities of <code>require.context</code>.</p> <p>Let's create the <code>Tools</code> system class and implement the <code>massiveRequre</code> method in it:</p> <pre><code>export class Tools {\n    static massiveRequire(req) {\n        const files = [];\n\n        req.keys().forEach(key =&gt; {\n            files.push({\n                key, data: req(key)\n            });\n        });\n\n        return files;\n    }\n}\n</code></pre> <p>And now we need to update the entry point: <pre><code>import { Config } from \"./game/Config\";\nimport { App } from \"./system/App\";\n\nApp.run(Config);\n</code></pre></p> <p>Now we can fully implement the <code>preload</code> method in the <code>Loader</code> class. We can do it in 2 steps:</p> <ol> <li>Add all resources from the loader config to the loading list using <code>this.loader.add</code> method.</li> <li>Start loading resources using <code>this.loader.load</code>.</li> </ol> <pre><code>export class Loader {\n    // ...\n    preload() {\n        for (const asset of this.config.loader) {\n            let key = asset.key.substr(asset.key.lastIndexOf('/') + 1);\n            key = key.substring(0, key.indexOf('.'));\n            if (asset.key.indexOf(\".png\") !== -1 || asset.key.indexOf(\".jpg\") !== -1) {\n                this.loader.add(key, asset.data.default)\n            }\n        }\n\n        return new Promise(resolve =&gt; {\n            this.loader.load((loader, resources) =&gt; {\n            this.resources = resources;\n            resolve();\n            });\n        });\n    }\n}\n</code></pre> <p>The <code>load</code> method of the <code>PIXI.Loader</code> object takes a callback function as a parameter, which will be called when all the resources have finished loading and become available for use.</p> <p>The callback function takes 2 parameters: the loader object itself and the second parameter is the loaded resources. Let's put them in the <code>resources</code> field in the <code>Loader</code> class, which we specially reserved for all loaded resources.</p>"},{"location":"pixi_project_template/#4-game-launch","title":"4. Game launch","text":"<p>In the <code>Application</code> class, we implement the <code>start</code> method, which will start the game after the resources are loaded:</p> <pre><code>// ...\nclass Application {\n// ... \n    start() {\n        this.scene = new this.config[\"startScene\"]();\n        this.app.stage.addChild(this.scene.container);\n    }\n</code></pre> <p>We could instantiate the scene class directly in the <code>start</code> method. But we want the shared code in the <code>system</code> folder to be unrelated to or dependent on the game code in the <code>game</code> folder. To do this, we have separated the common system code and the project code. At the same time, the system code can know about the parameters it needs through the game config, which we pass to the <code>App</code> class when launching applications. So in this case, instead of directly creating the game scene object directly in the <code>Application</code> class, we'd better create it through a parameter in the config. Add the <code>startScene</code> parameter to the game config in <code>Config.js</code>:</p> <pre><code>import { Game } from \"./Game\";\n\nexport const Config = {\n    // ...\n    startScene: Game,\n};\n</code></pre> <p>And create the <code>Game</code> class itself in game folder <code>/src/scripts/game/Game</code>:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\n\nexport class Game {\n    constructor() {\n        this.container = new PIXI.Container();\n    }\n}\n</code></pre> <p>The scene class is based on the <code>PIXI.Container</code>. And we will add all objects added to the scene to this container. And we added the scene container itself to the main <code>app.stage</code> container in the start method of the <code>Application</code> class.</p>"},{"location":"pixi_project_template/#5-sprite-output","title":"5. Sprite Output","text":"<p>To render sprites, we need to implement a helper method in the <code>Application</code> class:</p> <pre><code>    res(key) {\n        return this.loader.resources[key].texture;\n    }\n\n    sprite(key) {\n        return new PIXI.Sprite(this.res(key));\n    }\n</code></pre> <p>We know that all loaded resources are stored in the <code>resources</code> property of our custom <code>Loader</code> class. Getting the required resource by key, we can create a new instance of the <code>PIXI.Sprite</code> class. Now, in the code of the game, it will be enough for us to use only the call to the <code>App.sprite</code> method to get the required <code>PIXI.Sprite</code> instance and work with it further. Let's render the background image:</p> <pre><code>export class Game {\n    constructor() {\n        this.container = new PIXI.Container();\n        this.createBackground();\n    }\n    createBackground() {\n        this.bg = App.sprite(\"bg\");\n        this.bg.width = window.innerWidth;\n        this.bg.height = window.innerHeight;\n        this.container.addChild(this.bg);\n    }\n</code></pre>"},{"location":"pixi_project_template/#6-scenes-manager","title":"6. Scenes Manager","text":"<p>Let's create a scene manager for easy switching between scenes in the game. Let's create a base scene class:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"./App\";\n\nexport class Scene {\n    constructor() {\n        this.container = new PIXI.Container();\n        this.container.interactive = true;\n        this.create();\n        App.app.ticker.add(this.update, this);\n    }\n\n    create() {}\n    update() {}\n    destroy() {}\n\n    remove() {\n        App.app.ticker.remove(this.update, this);\n        this.destroy();\n        this.container.destroy();\n    }\n}\n</code></pre> <p>Let's add 3 methods to the base class that can be overridden in the project scene: - <code>create</code> - <code>update</code> - <code>destroy</code></p> <p>In the constructor, we will perform the universal actions required for each scene in the game: - create a scene container - call the <code>create</code> method, which will be overridden in the game scene - add <code>PIXI</code> ticker with <code>update</code> method so that it is called on every animation frame - add the <code>remove</code> method that will be called by the manager when the scene is destroyed and implement the deletion of the ticker in it</p> <p>Now let's create the manager itself to manage and switch scenes:</p> <p><pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"./App\";\n\nexport class ScenesManager {\n    constructor() {\n        this.container = new PIXI.Container();\n        this.container.interactive = true;\n        this.scene = null;\n    }\n\n    start(scene) {\n        if (this.scene) {\n            this.scene.remove();\n        }\n\n        this.scene = new App.config.scenes[scene]();\n        this.container.addChild(this.scene.container);\n    }\n}\n</code></pre> The manager's only job is to run the scene. In this case, if any scene has already been launched, it must be deleted. We can start the scene by the key passed as a parameter to the <code>start</code> method. Which scene class corresponds to this key, we specify in the global config:</p> <pre><code>// ...\nexport const Config = {\n    // ...\n    scenes: {\n        \"Game\": Game\n    }\n};\n</code></pre> <p>Let's finalize our game scene <code>Game</code> by making this class an inheritor of the base class of the scene:</p> <pre><code>//...\nimport { Scene } from \"../system/Scene\";\n\nexport class Game extends Scene {\n    // ...\n}\n</code></pre> <p>And all that's left is to change the scene launch method in the <code>App.js</code> application class:</p> <pre><code>// ...\nimport { ScenesManager } from \"./ScenesManager\";\n\nclass Application {\n    run(config) {\n        //...\n        this.scenes = new ScenesManager();\n        this.app.stage.addChild(this.scenes.container);\n    }\n    // ...\n    start() {\n        this.scenes.start(\"Game\");\n    }\n}\n</code></pre>"},{"location":"pixi_project_template/#7-useful-links","title":"7. Useful links","text":"<ul> <li>Final source code</li> <li><code>PIXI.Application</code></li> <li><code>PIXI.Loader</code></li> <li><code>PIXI.Sprite</code></li> <li><code>PIXI.Container</code></li> <li>GSAP</li> <li>PIXI</li> <li>Webpack </li> <li>Babel</li> <li>Webpack <code>require.context</code></li> </ul>"},{"location":"runner/","title":"Create a platformer with PixiJS","text":"<p>In this article, we will create an infinite runner game using PIXI.</p>"},{"location":"runner/#video-version","title":"Video version","text":""},{"location":"runner/#additional-materials","title":"Additional materials","text":"<ul> <li>Complete source code</li> <li>Preview demo</li> </ul> <p>Before starting the development, we need to perform 2 steps:</p> <p> Download our PIXI project template. You can start working on the game right now or check out the tutorial on how to create a PIXI project template.</p> <p> Download the assets pack for our game. Assets provided by the great website kenney.nl</p>"},{"location":"runner/#1-create-a-moving-background","title":"1. Create a moving background","text":"<p>By moving the repeating background image from right to left on the screen, we will create the effect of constant movement.</p> <p>In the main game scene class <code>game/GameScene.js</code>, let's create a background:</p> <pre><code>import { Background } from \"./Background\";\nimport { Scene } from '../system/Scene';\n\nexport class GameScene extends Scene {\n    create() {\n        this.createBackground();\n    }\n\n    createBackground() {\n        this.bg = new Background();\n        this.container.addChild(this.bg.container);\n    }\n\n    update(dt) {\n        this.bg.update(dt);\n    }\n}\n</code></pre> <p>Create a <code>Background.js</code> file</p> <p><pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\n\nexport class Background {\n    constructor() {\n        this.speed = App.config.bgSpeed;\n        this.container = new PIXI.Container();\n        this.createSprites();\n    }\n    createSprites() {\n    }\n}\n</code></pre> We will move the background movement speed parameter to the global config:</p> <pre><code>export const Config = {\n    bgSpeed: 2,\n    // ...\n};\n</code></pre> <p>We must constantly move the background image from right to left at a given speed.</p> <p>But if we move one single image, then at some point the image will not fit the screen and the player will see a black background. To prevent this from happening, we can connect several background images together and move them all at the same time.  And when the first image is completely hidden behind the left edge of the screen, we will automatically move it to the right edge.</p> <p>First, let's create all 3 sprites one after the other.</p> <p><code>Background.js</code>: <pre><code>    createSprites() {\n        this.sprites = [];\n\n        for (let i = 0; i &lt; 3; i++) {\n            this.createSprite(i);\n        }\n    }\n\n    createSprite(i) {\n        const sprite = App.sprite(\"bg\");\n\n        sprite.x = sprite.width * i;\n        sprite.y = 0;\n        this.container.addChild(sprite);\n        this.sprites.push(sprite);\n    }\n</code></pre> Each sprite is indented along the x-axis by a distance equal to the width of all background images to its left.</p> <p>Now we will implement a method for moving an individual sprite and moving it to the rightmost position, provided that the sprite is hidden behind the left border of the screen:</p> <pre><code>    move(sprite, offset) {\n        const spriteRightX = sprite.x + sprite.width;\n\n        const screenLeftX  = 0;\n\n        if (spriteRightX &lt;= screenLeftX) {\n            sprite.x += sprite.width * this.sprites.length;\n        }\n\n        sprite.x -= offset;\n    }\n</code></pre> <p>It remains to run the <code>move</code> method for each sprite in the <code>update</code> method:</p> <pre><code>    update(dt) {\n        const offset = this.speed * dt;\n\n        this.sprites.forEach(sprite =&gt; {\n            this.move(sprite, offset);\n        });\n    }\n</code></pre>"},{"location":"runner/#2-creating-a-single-platform","title":"2. Creating a single platform","text":"<p>Now let's create our first platform, which the hero will land on at the very beginning of the game. To do this, we will display the platform tiles on the screen, connecting them together so that a sufficiently long surface is created. Let's start by calling the method in the <code>GameScene</code> class to create a platform:</p> <pre><code>    create() {\n        //...\n        this.createPlatform({\n            rows: 4,\n            cols: 6,\n            x: 200\n        });\n    }\n    createPlatform(data) {\n        const platform = new Platform(data.rows, data.cols, data.x);\n        this.container.addChild(platform.container);\n    }\n</code></pre> <p>We will describe the functionality of the platform in the <code>Platform</code> class. We pass 3 required parameters to the <code>constructor</code> of this class, which will determine the platform being created:   - number of rows   - number of columns   - x-coordinate on the screen from which we want to start drawing the platform</p> <p>Now let's create the <code>Platform</code> class:</p> <p><pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from '../system/App';\n\nexport class Platform {\n    constructor(rows, cols, x) {\n        this.rows = rows;\n        this.cols = cols;\n    }\n}\n</code></pre> We will need to know the full dimensions of the platform being created: width and height. We know that the platform will consist of tiles of the same size. Thus, knowing the dimensions of one tile and knowing the number of such tiles in a row and in a column, it is easy to calculate the total width and height of the platform:</p> <pre><code>export class Platform {\n    constructor(rows, cols, x) {\n        // ...\n        this.tileSize = PIXI.Texture.from(\"tile\").width;\n        this.width = this.tileSize * this.cols;\n        this.height = this.tileSize * this.rows;\n    }\n}\n</code></pre> <p>All created tiles will need to be placed in one common container of the platform, which in turn is already placed in the outer container of the scene. Let's create a container for tiles:</p> <p><pre><code>export class Platform {\n    constructor(rows, cols, x) {\n        // ...\n        this.createContainer(x);\n    }\n    createContainer(x) {\n        this.container = new PIXI.Container();\n        this.container.x = x;\n        this.container.y = window.innerHeight - this.height;\n    }\n}\n</code></pre> When creating a container, we specify its <code>x</code> coordinate obtained from a parameter in the constructor. Thus, we shift the left side of the platform to this coordinate. As the <code>y</code> coordinate, we specify a value at which the platform will touch the bottom of the screen with its bottom side. This way we will create the effect that the platform sticks out of the ground. We know that the coordinates of the container correspond to the coordinate of the first tile in the container. And this is the top leftmost tile. Thus, if we shift the entire platform up by a distance equal to its height, we will achieve the desired effect.</p> <p>Now let's create the tiles themselves:</p> <p><pre><code>export class Platform {\n    constructor(rows, cols, x) {\n        // ...\n        this.createTiles();\n    }\n    createTiles() {\n        for (let row = 0; row &lt; this.rows; row++) {\n            for (let col = 0; col &lt; this.cols; col++) {\n                this.createTile(row, col);\n            }\n        }\n    }\n\n    createTile(row, col) {\n        const texture = row === 0 ? \"platform\" : \"tile\" \n        const tile = App.sprite(texture);\n        this.container.addChild(tile);\n        tile.x = col * tile.width;\n        tile.y = row * tile.height;\n    }\n}\n</code></pre> We create tiles in a loop, going through all the rows and columns of the platform. On the first line of the platform, use <code>platform</code> (grass sprite) as the sprite. In other cases, we use the standard <code>tile</code> sprite (an image with the ground). For each tile, we calculate its position based on its position in the platform. To get the correct coordinates, you need to multiply the column of the tile by its width, and the row by its height.</p>"},{"location":"runner/#3-creating-a-hero","title":"3. Creating a hero","text":"<p>Let's place the hero sprite on the platform we just created.</p> <p>Let's create the <code>Hero.js</code> class:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from '../system/App';\n\nexport class Hero {\n    constructor() {\n        this.createSprite();\n    }\n\n    createSprite() {\n    }\n}\n</code></pre> <p>Implement the <code>createSprite</code> method:</p> <pre><code>    createSprite() {\n        this.sprite = new PIXI.AnimatedSprite([\n            App.res(\"walk1\"),\n            App.res(\"walk2\")\n        ]);\n\n        this.sprite.x = App.config.hero.position.x;\n        this.sprite.y = App.config.hero.position.y;\n        this.sprite.loop = true;\n        this.sprite.animationSpeed = 0.1;\n        this.sprite.play();\n    }\n</code></pre> <p>The hero consists of two images: <code>walk1</code> and <code>walk2</code>. From these two images, we can create a frame-by-frame animation of walking. For this we use the <code>PIXI.AnimatedSprite</code> class. In the constructor of this class, we pass an array of textures from which we want to create an animation. And the <code>App.res</code> method just returns the texture by key.</p> <p>Let's place the sprite in the initial position, which we will set in the global game config <code>Config.js</code>:</p> <pre><code>// ...\nexport const Config = {\n    // ...\n    hero: {\n        position: {\n            x: 350,\n            y: 595\n        }\n    },\n    // ...\n};\n</code></pre> <p>Set the <code>loop</code> flag to <code>true</code> to loop the animation and set the desired playback speed:</p> <pre><code>        this.sprite.loop = true;\n        this.sprite.animationSpeed = 0.1;\n</code></pre> <p>And  call the <code>play</code> method to start animation.</p> <pre><code>        this.sprite.play();\n</code></pre> <p>Now we have a hero class and we can create a hero object on the stage in <code>GameScene.js</code>:</p> <pre><code>export class GameScene extends Scene {\n    create() {\n        // ...\n        this.createHero();\n    }\n\n    createHero() {\n        this.hero = new Hero();\n        this.container.addChild(this.hero.sprite);\n    }\n}\n</code></pre>"},{"location":"runner/#4-creating-multiple-platforms","title":"4. Creating multiple platforms","text":"<p>At this point, we have created the first platform and placed the hero on it. But in our game, platforms should create automatically and endlessly. Therefore, it's time to write the code for generation of all the platforms.</p> <p>Let's create the <code>Platforms</code> class, which will be responsible for generating all the platforms in the game: <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\nimport { Platform } from \"./Platform\";\n\nexport class Platforms {\n    constructor() {\n        this.platforms = [];\n        this.container = new PIXI.Container();\n    }\n}\n</code></pre></p> <p>We will place all created platforms in the <code>this.platforms</code> array. And we will also add all platforms as children in a single container <code>this.container</code>, which we will then add to the stage.</p> <p>Since we decided that the <code>Platforms</code> class should create all the platforms, it means that this class should create the very first platform also. Then we will transfer the code for creating the first platform from the <code>GameScene</code> to the <code>Platforms</code>:</p> <pre><code>export class Platforms {\n    constructor() {\n        //...\n        this.createPlatform({\n            rows: 4,\n            cols: 6,\n            x: 200\n        });\n    }\n    createPlatform(data) {\n        const platform = new Platform(data.rows, data.cols, data.x);\n        this.container.addChild(platform.container);\n    }\n}\n</code></pre> <p>Then on the stage itself, instead of creating the first platform, we need to initialize an instance of the <code>Platforms</code> class:</p> <p><pre><code>export class GameScene extends Scene {\n    create() {\n        // ...\n        this.createPlatforms();\n    }\n\n    //...\n    createPlatforms() {\n        this.platfroms = new Platforms();\n        this.container.addChild(this.platfroms.container);\n    }\n\nupdate(dt) {\n    // ...\n    this.platfroms.update(dt);\n    }\n}\n</code></pre> In addition, we added the call to the <code>Platforms.update</code> method in the <code>GameScene.update</code> method. In this way, we will constantly check the status of the platforms manager and perform certain actions at the right time.</p> <p>And what, for example, actions do we need to track and perform at certain moments? For example, we can automatically create platforms until the last created platform goes off screen! Let's implement the <code>update</code> method in the <code>Platforms</code> class:</p> <p><pre><code>    update() {\n        if (this.current.container.x + this.current.container.width &lt; window.innerWidth) {\n            this.createPlatform(this.randomData);\n        }\n    }\n</code></pre> If the last created platform fits entirely on the screen (that is, its right side coordinate is less than the width of the screen), then we want to create the next platform. Thus, we say that we want to create platforms until the entire screen is filled with platforms. In other words, we create new platforms until the last created platform goes beyond the right border of the screen!</p> <p>As you can see, we placed the last created platform in the <code>this.current</code> property. Therefore, let's add its setting to the <code>createPlatform</code> method along with adding the created platform to the <code>this.platforms</code> array:</p> <pre><code>export class Platforms {\n    //...\n    createPlatform(data) {\n        const platform = new Platform(data.rows, data.cols, data.x);\n        this.container.addChild(platform.container);\n        this.platforms.push(platform);\n        this.current = platform;\n    }\n}\n</code></pre> <p>Each next platform, unlike the first one, we will create with random parameters. Random parameters are returned to us by the <code>randomData</code> getter.</p> <p>The parameters used, although random, must still be within certain ranges so that the platforms are created in reasonable sizes and positions. Let's describe such limits in the global config <code>Config.js</code>:</p> <p><pre><code>    platforms: {\n        ranges: {\n            rows: {\n                min: 2,\n                max: 6\n            },\n            cols: {\n                min: 3,\n                max: 9\n            },\n            offset: {\n                min: 60,\n                max: 200\n            }\n        }\n    },\n</code></pre> Here we have specified the minimum and maximum number of rows and columns in one platform, as well as the minimum and maximum offset relative to the previous platform. Now we can implement the <code>randomData</code> getter based on the given ranges:</p> <pre><code>    get randomData() {\n        this.ranges = App.config.platforms.ranges;\n        let data = { rows: 0, cols: 0, x: 0 };\n\n        const offset = this.ranges.offset.min + Math.round(Math.random() * (this.ranges.offset.max - this.ranges.offset.min));\n\n        data.x = this.current.container.x + this.current.container.width + offset;\n        data.cols = this.ranges.cols.min + Math.round(Math.random() * (this.ranges.cols.max - this.ranges.cols.min));\n        data.rows = this.ranges.rows.min + Math.round(Math.random() * (this.ranges.rows.max - this.ranges.rows.min));\n\n        return data;\n    }\n</code></pre>"},{"location":"runner/#5-enable-physics","title":"5. Enable physics","text":"<p>Before we start the movement of the platforms, we need to activate physics in the projects. To do this, first let's install the npm package with the <code>MatterJS</code> physical library:</p> <pre><code>npm i matter-js\n</code></pre> <p>Let's activate the engine in <code>App.js</code>. To do this, follow 3 steps:   - engine initialization   - creating a runner   - running the engine</p> <pre><code>import * as Matter from 'matter-js';\n// ...\nclass Application {\n    run(config) {\n        // ...\n        this.createPhysics();\n    }\n\n    createPhysics() {\n        this.physics = Matter.Engine.create();\n        const runner = Matter.Runner.create();\n        Matter.Runner.run(runner, this.physics);\n    }\n    // ...\n\n}\n</code></pre>"},{"location":"runner/#6-the-physical-body-of-platforms","title":"6. The physical body of platforms","text":"<p>After we have added physics to the project, we need to tell the physics engine about all the objects that will be enabled for physics processing. Let's start with platforms. Add physical bodies to the created platforms and thus let the physics engine know about the platforms.</p> <p>What is the physical body of the platform? In fact, the platform is a rectangular sprite.</p> <p>In order to create the physical body of the platform that the engine can process, we need to create a rectangle that exactly matches the outline of the platform. We can accurately calculate the size and position of such a rectangle by taking the coordinates and dimensions of the current platform.</p> <p>In the <code>Platform.js</code> file:</p> <pre><code>import * as Matter from 'matter-js';\n\nexport class Platform {\n    constructor(rows, cols, x) {\n        // ...\n        // specify the speed of the platform\n        this.dx = App.config.platforms.moveSpeed;\n        this.createBody();\n    }\n\n    createBody() {\n        // create a physical body\n        this.body = Matter.Bodies.rectangle(this.width / 2 + this.container.x, this.height / 2 + this.container.y, this.width, this.height, {friction: 0, isStatic: true});\n        // add the created body to the engine\n        Matter.World.add(App.physics.world, this.body);\n        // save a reference to the platform object itself for further access from the physical body object\n        this.body.gamePlatform = this;\n    }\n}\n</code></pre> <p>And let's take out the value of the platforms speed into the global config for the convenience of configuration:</p> <pre><code>export const Config = {\n    // ...\n    platforms: {\n        // ...\n        moveSpeed: -1.5\n    }\n    // ...\n};\n</code></pre>"},{"location":"runner/#7-movement-of-platforms","title":"7. Movement of platforms","text":"<p>Now we have the physical body of the platform and we can make the platform move by moving its physical body. Then we will move the platform container with all the tiles to the new position of the physical body.</p> <p>Let's create a new <code>move</code> method, in which we will set the physical body to a new position, taking into account the platform speed specified in the <code>this.dx</code> property.</p> <pre><code>export class Platform {\n    // ...\n    move() {\n        if (this.body) {\n            Matter.Body.setPosition(this.body, {x: this.body.position.x + this.dx, y: this.body.position.y});\n            this.container.x = this.body.position.x - this.width / 2;\n            this.container.y = this.body.position.y - this.height / 2;\n        }\n    }\n}\n</code></pre> <p>After setting the physical body to a new position, move the platform container to the same position, thus moving all the tiles of the platform to the correct place.</p> <p>It remains to run the <code>move</code> method for all created platforms in the <code>Platforms</code> class: <pre><code>export class Platforms {\n    // ...\n    update() {\n        // ...\n        this.platforms.forEach(platform =&gt; platform.move());\n    }\n}\n</code></pre></p>"},{"location":"runner/#8-the-physical-body-of-the-hero","title":"8. The physical body of the hero","text":"<p>By analogy with the platform, let's create a physical body for the hero in the <code>Hero.js</code> file:</p> <p><pre><code>import * as Matter from 'matter-js';\n// ...\nexport class Hero {\n    constructor() {\n        // ...\n        this.createBody();\n        App.app.ticker.add(this.update.bind(this));\n    }\n\n    // [07]\n    createBody() {\n        this.body = Matter.Bodies.rectangle(this.sprite.x + this.sprite.width / 2, this.sprite.y + this.sprite.height / 2, this.sprite.width, this.sprite.height, {friction: 0});\n        Matter.World.add(App.physics.world, this.body);\n        this.body.gameHero = this;\n    }\n\n    update() {\n        this.sprite.x = this.body.position.x - this.sprite.width / 2;\n        this.sprite.y = this.body.position.y - this.sprite.height / 2;\n    }\n}\n</code></pre> As well as for the platform we created a rectangle body in the position of the hero and in its dimensions.</p> <p>Then we added the created body to the engine and saved a reference to the hero itself in the <code>body</code> object. We will need this later when processing collisions, when we will have access to the colliding physical bodies.</p> <p>In addition, we have created an <code>update</code> method that is added to the <code>PIXI</code> ticker and will be called on every frame of the animation. In it, we force the hero's sprite to the position of his physical body in order to synchronize them. Thus, wherever the hero's physical body is sent as a result of interaction with physical objects, the hero's sprite will be placed in the same position.</p>"},{"location":"runner/#9-hero-jump","title":"9. Hero jump","text":"<p>We will give the hero the opportunity to jump twice. This means that after the first jump, the hero will be able to perform another jump while he's in the air. Then he must land on the platform to make the next jump.</p> <p>Let's make the hero jump by pressing anywhere in the screen. We will listen to the <code>pointerdown</code> event in the <code>GameScene</code> class:</p> <pre><code>export class GameScene extends Scene {\n    // ...\n    createHero() {\n        // ...\n        this.container.interactive = true;\n        this.container.on(\"pointerdown\", () =&gt; {\n            this.hero.startJump();\n        });\n    }\n    // ...\n}\n</code></pre> <p>As you can see, now we need to implement the <code>startJump</code> method in the<code>Hero</code> class:</p> <pre><code>export class Hero {\n    constructor() {\n        // ...\n        this.dy = App.config.hero.jumpSpeed;\n        this.maxJumps = App.config.hero.maxJumps;\n        this.jumpIndex = 0;\n    }\n\n    startJump() {\n        if (this.jumpIndex &lt; this.maxJumps) {\n            ++this.jumpIndex;\n            Matter.Body.setVelocity(this.body, { x: 0, y: -this.dy });\n        }\n    }\n    // ...\n}\n</code></pre> <p>The <code>jumpIndex</code> counter limits the number of jumps until the next touch of the platform.  The maximum possible number of jumps is indicated in the property <code>this.maxJumps</code>.</p> <p>We use the physical engine to set the speed of the hero\u2019s physical body. For a jump, we need to move it only along the axis <code>y</code> up. This means that we need to set a negative displacement for the <code>y</code> coordinate, which is set in the <code>this.dy</code> property.</p> <p>And finally, we take out the values of the jump speed and the number of jumps into the global config for the convenience of configuration:</p> <pre><code>export const Config = {\n    // ...\n    hero: {\n        jumpSpeed: 15,\n        maxJumps: 2,\n        //...\n    }\n};\n</code></pre>"},{"location":"runner/#10-collision-of-the-hero-and-platform","title":"10. Collision of the hero and platform","text":"<p>Right now the hero can only perform jump 2 jumps because the <code>this.jumpIndex</code> counter never resets.  And at what point should this counter be reset to give the hero the opportunity for a new double jump?</p> <p>That is the moment when hero touches the platform. This means that the hero has landed on the ground and the previous jump is completed.</p> <p>How can we track the collision of the hero and the platform? To do this, we will again use the physics engine and the interaction of the physical bodies of the hero and the platform.</p> <p>The <code>Matter</code> physics engine will fire a collision event when two physics bodies collide. So we need to listen for this event. Let's do this in the <code>GameScene</code> class:</p> <p><pre><code>import * as Matter from 'matter-js';\nimport { App } from '../system/App';\n//...\n\nexport class GameScene extends Scene {\n    create() {\n        //...\n        this.setEvents();\n    }\n\n    setEvents() {\n        Matter.Events.on(App.physics, 'collisionStart', this.onCollisionStart.bind(this));\n    }\n\n    onCollisionStart(event) {\n        const colliders = [event.pairs[0].bodyA, event.pairs[0].bodyB];\n        const hero = colliders.find(body =&gt; body.gameHero);\n        const platform = colliders.find(body =&gt; body.gamePlatform);\n\n        if (hero &amp;&amp; platform) {\n            this.hero.stayOnPlatform(platform.gamePlatform);\n        }\n    }\n    // ...\n}\n</code></pre> The <code>onCollisionStart</code> method will run automatically when the <code>collisionStart</code> event occurs, which means that a collision of physical bodies has occurred.</p> <p>In this method, we get physical bodies that interact with each other. Since we created the <code>gameHero</code> and <code>gamePlatform</code> properties in the physical body objects of the hero and platform in advance, we can now check for the presence of such properties and determine from them what kind of body is involved in the collision.</p> <p>Finally, if we got both a hero and a platform, we'll call the <code>stayOnPlatform</code> method to set the hero on the platform.</p> <p>Let's implement this method in the <code>Hero</code> class:</p> <pre><code>export class Hero {\n    // ...\n\n    stayOnPlatform(platform) {\n        this.platform = platform;\n        this.jumpIndex = 0;\n    }\n</code></pre> <p>All we need to do in it is reset the counter and set the current platform to the <code>this.platform</code> property.</p> <p>And now we can improve the code of the <code>startJump</code> method by adding an additional check whether the hero is currently on the platform. If a jump is possible, then the <code>this.platform</code> property should be reset.</p> <pre><code>    startJump() {\n        if (this.platform || this.jumpIndex === 1) {\n            ++this.jumpIndex;\n            this.platform = null;\n            Matter.Body.setVelocity(this.body, { x: 0, y: -this.dy });\n        }\n    }\n</code></pre>"},{"location":"runner/#11-creating-diamonds","title":"11. Creating diamonds","text":"<p>In the game, the diamonds will be positioned above the platforms in such a way as to motivate the player to jump from the platform to collect them.</p> <p>We will create diamonds for each platform in the corresponding class. Let's create a certain number of diamond images above the platform:</p> <pre><code>// ...\nexport class Platform {\n    constructor(rows, cols, x) {\n        // ...\n        this.diamonds = [];\n        this.createDiamonds();\n    }\n\n    createDiamonds() {\n        const y = App.config.diamonds.offset.min + Math.random() * (App.config.diamonds.offset.max - App.config.diamonds.offset.min);\n\n        for (let i = 0; i &lt; this.cols; i++) {\n            if (Math.random() &lt; App.config.diamonds.chance) {\n                const diamond = new Diamond(this.tileSize * i, -y);\n                this.container.addChild(diamond.sprite);\n                this.diamonds.push(diamond);\n            }\n        }\n    }\n    // ...\n}\n</code></pre> <p>Let's loop through all the tiles of the platform and check the possibility of creating a diamond over each tile. The probability of creating a diamond over one tile is obtained from the property of the global config <code>App.config.diamonds.chance</code>.</p> <p>If we need to create a diamond over this tile, then we will create an instance of the <code>Diamond</code> class. Let's place the created object in the <code>this.diamonds</code> property and add it as a child element to the platform container.</p> <p>Let's add the settings for creating diamonds to the global config:</p> <pre><code>// ...\nexport const Config = {\n    // ...\n    diamonds: {\n        chance: 0.4,\n        offset: {\n            min: 100,\n            max: 200\n        }\n    }\n}\n</code></pre> <p>The chance property indicates the probability of a diamond being generated on each specific platform tile. The offset object defines the allowable height range at which the diamond must be positioned above the platform.</p> <p>It remains to implement the <code>Diamond</code> class. At the moment, we only implement in it the output of the diamond sprite:</p> <pre><code>import { App } from '../system/App';\n\nexport class Diamond {\n    constructor(x, y) {\n        this.sprite = App.sprite(\"diamond\");\n        this.sprite.x = x;\n        this.sprite.y = y;\n    }\n}\n</code></pre>"},{"location":"runner/#12-the-physical-body-of-a-diamond","title":"12. The physical body of a diamond","text":"<p>As we already know, all game objects that need to handle physics interactions (such as collision) need to create physics bodies and add them to the physics engine for processing.</p> <p>We have already created a physical body for the hero and the platforms, and thus have the opportunity to handle the collision of the hero with the platform. </p> <p>The player will be able to collect diamonds when they are touched by the hero's sprite while jumping. This means that diamonds also need to create a physical body. Let's improve the code in the <code>Diamond</code> class:</p> <pre><code>export class Diamond {\n    constructor(x, y) {\n        this.createSprite(x, y);\n    }\n\n    createSprite(x, y) {\n        this.sprite = App.sprite(\"diamond\");\n        this.sprite.x = x;\n        this.sprite.y = y;\n    }\n\n    createBody() {\n        this.body = Matter.Bodies.rectangle(this.sprite.width / 2 + this.sprite.x + this.sprite.parent.x, this.sprite.height / 2 + this.sprite.y + this.sprite.parent.y, this.sprite.width, this.sprite.height, {friction: 0, isStatic: true, render: { fillStyle: '#060a19' }});\n        this.body.gameDiamond = this;\n        this.body.isSensor = true;\n        Matter.World.add(App.physics.world, this.body);\n    }\n}\n</code></pre> <p>Here we created the physical body in the same way as we did for the platform and the hero. We used a rectangle at the sprite coordinates and the dimensions of the diamond sprite. As usual, we have stored a reference to the diamond object in the physical body object in order to access the diamond at the time of the collision events.</p> <p>In addition, we have set the <code>this.body.isSensor</code> property to <code>true</code>. This way, the hero sprite will be able to pass through the diamond image, unlike the platform, which should not pass the sprite through itself.</p> <p>It remains to call the <code>createBody</code> method after the diamond is added as a child element to the platform container in the <code>Platform.js</code> class:</p> <pre><code>    createDiamonds() {\n        const y = App.config.diamonds.offset.min + Math.random() * (App.config.diamonds.offset.max - App.config.diamonds.offset.min);\n\n        for (let i = 0; i &lt; this.cols; i++) {\n            if (Math.random() &lt; App.config.diamonds.chance) {\n                this.createDiamond(this.tileSize * i, -y);\n            }\n        }\n    }\n\n    createDiamond(x, y) {\n            const diamond = new Diamond(x, y);\n            this.container.addChild(diamond.sprite);\n            diamond.createBody();\n            this.diamonds.push(diamond);\n    }\n</code></pre>"},{"location":"runner/#13-collecting-diamonds","title":"13. Collecting diamonds","text":"<p>When the hero touches the diamond, it will be considered collected and should disappear from the screen. How to determine the moment of collision? We already did this for the hero and platform in the <code>GameScene.js</code> class when we implemented the <code>onCollisionStart</code> method. Now let's extend this method to check for the presence of a diamond object and handle such a collision:</p> <p><pre><code>export class GameScene extends Scene {\n    // ...\n    onCollisionStart(event) {\n        // ...\n        const diamond = colliders.find(body =&gt; body.gameDiamond);\n\n        if (hero &amp;&amp; diamond) {\n            this.hero.collectDiamond(diamond.gameDiamond);\n        }\n    }\n    // ...\n}\n</code></pre> We need to implement the <code>collectDiamond</code> method in the <code>Hero.js</code> class:</p> <p><pre><code>import * as Matter from 'matter-js';\nimport * as PIXI from \"pixi.js\";\nimport { App } from '../system/App';\n\nexport class Hero {\n    constructor() {\n        // ...\n        this.score = 0;\n    }\n    collectDiamond(diamond) {\n        ++this.score;\n        Matter.World.remove(App.physics.world, diamond.body);\n        diamond.sprite.destroy();\n        diamond.sprite = null;\n    }\n    // ...\n}\n</code></pre> When collecting a diamond, we destroy its physical body and destroy the sprite itself. We also increase the hero's score counter, which we will later display on the screen as a game score.</p>"},{"location":"runner/#14-ui","title":"14. UI","text":"<p>Let's display the player's score on the screen. Let's create the <code>LabelScore</code> class, which will be the successor of <code>PIXI.Text</code>:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\n\nexport class LabelScore extends PIXI.Text {\n    constructor() {\n        super();\n        this.x = App.config.score.x;\n        this.y = App.config.score.y;\n        this.anchor.set(App.config.score.anchor);\n        this.style = App.config.score.style;\n        this.renderScore();\n    }\n\n    renderScore(score = 0) {\n        this.text = `Score: ${score}`;\n    }\n}\n</code></pre> <p>Let's take out all the positioning and text style parameters in the global config <code>Config.js</code>:</p> <pre><code>export const Config = {\n    score: {\n        x: 10,\n        y: 10,\n        anchor: 0,\n        style: {\n            fontFamily: \"Verdana\",\n            fontWeight: \"bold\",\n            fontSize: 44,\n            fill: [\"#FF7F50\"]\n        }\n    },\n    // ...\n};\n</code></pre> <p>Let's create an instance of this class and add it to the game scene:</p> <pre><code>export class GameScene extends Scene {\n    create() {\n        // ...\n        this.createUI();\n    }\n\n    createUI() {\n        this.labelScore = new LabelScore();\n        this.container.addChild(this.labelScore);\n        this.hero.sprite.on(\"score\", () =&gt; {\n            this.labelScore.renderScore(this.hero.score);\n        });\n    }\n}\n</code></pre> <p>As you can see, it remains to add the launch of the <code>score</code> event to the hero object at the time of collecting the diamond:</p> <pre><code>export class Hero {\n    // ...\n    collectDiamond(diamond) {\n        // ...\n        this.sprite.emit(\"score\");\n    }\n}\n</code></pre>"},{"location":"runner/#15-restarting-the-game-when-the-hero-falls","title":"15. Restarting the game when the hero falls","text":"<p>We will complete the development by restarting the game after the hero falls off the platform. You need to restart the game on the event of the death of the hero. Let's start by adding a handler for such an event in the <code>GameScene</code> class:</p> <pre><code>export class GameScene extends Scene {\n    createHero() {\n        // ...\n        this.hero.sprite.once(\"die\", () =&gt; {\n            App.scenes.start(\"Game\");\n        });\n    }\n}\n</code></pre> <p>We know that calling the <code>start</code> method of the <code>ScenesManager</code> class will automatically call the <code>destroy</code> method of the current scene before starting a new scene. Thus, in this method, it is necessary to implement all the logic for closing the scene. Namely: destroy all objects on the stage and disable all event handlers. Let's do it:</p> <pre><code>destroy() {\n    Matter.Events.off(App.physics, 'collisionStart', this.onCollisionStart.bind(this));\n    App.app.ticker.remove(this.update, this);\n    this.bg.destroy();\n    this.hero.destroy();\n    this.platfroms.destroy();\n    this.labelScore.destroy();\n}\n</code></pre> <p>Now we implement the destroy method in each of the listed objects. <code>Background.js</code> <pre><code>destroy() {\n    this.container.destroy();\n}\n</code></pre></p> <p><code>Platforms.js</code> <pre><code>destroy() {\n    this.platforms.forEach(platform =&gt; platform.destroy());\n    this.container.destroy();\n}\n</code></pre></p> <p><code>Platform.js</code> <pre><code>destroy() {\n    Matter.World.remove(App.physics.world, this.body);\n    this.diamonds.forEach(diamond =&gt; diamond.destroy());\n    this.container.destroy();\n}\n</code></pre></p> <p><code>Diamond.js</code> <pre><code>destroy() {\n    if (this.sprite) {\n        App.app.ticker.remove(this.update, this);\n        Matter.World.remove(App.physics.world, this.body);\n        this.sprite.destroy();\n        this.sprite = null;\n    }\n}\n</code></pre></p> <p>Finally, let's finish by firing the <code>die</code> event on the <code>Hero</code> class:</p> <p><code>Hero.js</code> <pre><code>update() {\n    // ...\n    if (this.sprite.y &gt; window.innerHeight) {\n        this.sprite.emit(\"die\");\n    }\n}\n\ndestroy() {\n    App.app.ticker.remove(this.update, this);\n    Matter.World.add(App.physics.world, this.body);\n    this.sprite.destroy();\n}\n</code></pre></p>"},{"location":"tower-defense/","title":"\u0421reating Tower Defense game with PIXI","text":"<p>In this course we will create a tower defense game using PixiJS.</p>"},{"location":"tower-defense/#additional-materials","title":"Additional materials","text":"<ul> <li>Complete source code</li> <li>Preview demo</li> </ul> <p>Before starting the development, we need to make 2 steps:</p> <p> Download our PIXI project template. You can start working on the game right now or check out the tutorial on how to create a PIXI project template.</p> <p> Download game assets:</p> <ul> <li>sprites</li> <li>tilemap created in Tiled editor</li> </ul>"},{"location":"tower-defense/#1-creating-the-tile","title":"1. Creating the tile","text":"<p>So, we downloaded and unpacked our project template, in which we will continue to work. Usually, the first thing I start developing a new game with is creating a background image on the screen. In this project, instead of a background image, we will use the entire level map. We prepared this map in advance in the Tiled program and it has a tilemap format. This means that the entire map consists of small tiles. Level data is stored in two files:</p> <ul> <li><code>tilemap.json</code></li> <li><code>tilemap.png</code></li> </ul> <p>Let's place them in the appropriate folders in the project:</p> <ul> <li><code>/src/json/tilemap.json</code></li> <li><code>/src/sprites/tilemap.png</code></li> </ul> <p>To create a map on the game scene, we first need to learn how to parse the tilemap.png image so that we can draw only the tiles we need.</p> <p>Let's create a <code>Tile</code> class that will be responsible for drawing the section of the map that we need:</p> <pre><code>import { EventEmitter } from \"events\";\nimport * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\n\nexport class Tile extends EventEmitter {\n    constructor(id) {\n        super();\n        this.atlas = App.res(\"tilemap\");\n        this.id = id;\n        this.createSprite();\n    }\n\n    createSprite() {\n    }\n}\n</code></pre> <p>The <code>Tile</code> class will be a child of <code>EventEmitter</code> because we want instances of this class to be able to fire the events we need. For example, a tower is a type of <code>Tile</code>. The tower may have events that we would like to be able to track in the future.</p> <p>In the <code>this.atlas</code> field we will get the texture of the loaded tilemap asset. Let each tile have its own ID number in the atlas, by which we can specifically identify the tile by determining its position. Thus, before we understand how to draw the desired part of the image, let's determine its position by ID.</p> <p>First, let's manually set the number of rows and columns of our atlas image <code>tilemap.png</code> in the game config, and also directly indicate the size of the tiles:</p> <pre><code>import { Tools } from \"../system/Tools\";\nimport { GameScene } from \"./GameScene\";\n\nexport const Config = {\n    loader: Tools.massiveRequire(require[\"context\"]('./../../sprites/', true, /\\.(mp3|png|jpe?g)$/)),\n    scenes: {\n        \"Game\": GameScene\n    },\n    atlas: {\n        cols: 23,\n        rows: 13,\n        tileSize: 64\n    }    \n};\n</code></pre> <p>Now, knowing the total number of rows and columns of the atlas image, we can calculate which row and which column has a tile with a given ID:</p> <pre><code>    get position() {\n        let index = 0;\n\n        for (let row = 0; row &lt; App.config.atlas.rows; row++) {\n            for (let col = 0; col &lt; App.config.atlas.cols; col++) {\n                ++index;\n                if (index === this.id) {\n                    return {row, col};\n\n               }\n            }\n        }\n\n        return {row: 0, col: 0};\n    }\n</code></pre> <p>Having defined the tile's row and column in the tilemap grid, we can finally draw it:</p> <pre><code>    createSprite() {\n        const x = App.config.atlas.tileSize * this.position.col;\n        const y = App.config.atlas.tileSize * this.position.row;\n        const texture = new PIXI.Texture(this.atlas, new PIXI.Rectangle(x + 1, y + 1, App.config.atlas.tileSize - 2, App.config.atlas.tileSize - 2));\n        this.sprite = new PIXI.Sprite(texture);\n        this.sprite.anchor.set(0.5);\n    }\n</code></pre> <p>We find the desired tile coordinates based on its position in the tilemap grid, taking into account the size of the tile. Here we're using a 1px offset from each edge of the tile, since our map was generated with that offset to avoid potential frame overlap issues.</p> <p>Now it remains to check that the tiles are created correctly:</p> <pre><code>import { Scene } from '../system/Scene';\nimport { Tile } from './Tile';\n\nexport class GameScene extends Scene {\n    create() {\n        const tile = new Tile(1);\n        this.container.addChild(tile.sprite);\n    }\n}\n</code></pre>"},{"location":"tower-defense/#2-creating-the-level","title":"2. Creating the level","text":"<p>So we learned how to create a specific tile by its ID. This means we can draw the entire map specified in <code>tilemap.json</code>. Let's create a new class <code>LevelMap</code> for this.</p> <ol> <li>We will receive the level data from the <code>tilemap.json</code> into the <code>const TilemapJson</code> variable using the <code>require</code> mechanism, reading the contents of the corresponding file.</li> <li>Let's create a container <code>this.container</code>, into which we will place the created tile sprites.</li> <li>Let's create a field <code>this.tiles</code>, in which we will place all the created tiles.</li> <li>We will implement the map rendering function in the <code>this.render</code> method</li> </ol> <pre><code>import * as PIXI from \"pixi.js\";\nimport { Tile } from \"./Tile\";\nimport { App } from \"../system/App\";\nconst TilemapJson = require(\"../../json/tilemap.json\");\n\nexport class LevelMap {\n    constructor() {\n        this.container = new PIXI.Container();\n        this.tiles = {};\n        this.render();\n    }\n\n    render() {\n    }\n}\n</code></pre> <p>So, we need to implement the <code>render</code> method to render the level map on the game scene.</p> <p>Let's determine the data that we need to draw the map on the game scene:</p> <ol> <li>In <code>Tiled</code>, we created a level that consists of an 18 x 32 grid of tiles.</li> <li>In addition, we have created 5 layers on this map.</li> <li>And also in our game we plan to draw tiles 2 times smaller than their original size in the atlas. That is, we will render tiles with a size of 32px instead of 64x. Let's add this data to the game config:</li> </ol> <pre><code>export const Config = {\n    // ...\n    level: {\n        rows: 18,\n        cols: 32,\n        layers: 5,\n        tileSize: 32\n    }\n};\n</code></pre> <p>Please note that in the <code>level</code> field we indicate exactly the data related directly to our level. So, our game map consists of an 18 x 32 grid, that is, it has only 18 rows and 32 tiles in each row. And in the <code>atlas</code> field, that we created in the previous step, we store information directly about the <code>tilemap.png</code> atlas, which in turn consists of a 23 X 13 grid, where each tile has a tile size of 64px.</p> <p>We know that our level map contains 5 layers, which we added ourselves when we created the map in the <code>Tiled</code>. This means that we need to iterate through each layer in the generated map and check if any tile is created in that layer at a given position:</p> <pre><code>    render() {\n        for (let layer = 0; layer &lt; App.config.level.layers; layer++) {\n            let index = 0;\n            const layerData = TilemapJson.layers[layer];\n            this.tiles[layerData.name] = [];\n        }\n    }\n</code></pre> <p>As you can see, information about the presence of a tile in the grid can be obtained from data about the current layer from <code>tilemap.json</code>. Let's save this data in <code>layerData</code>. Let each property of the <code>this.tiles</code> object refer to a specific map layer.</p> <p>If <code>tilemap.json</code> contains data for the current layer, then we can find out the tile ID by the <code>index</code> counter, which increases by 1 for each next tile checked. Thus, let's loop through all the columns in all the rows of our map, increasing the <code>index</code> parameter in each iteration. This way we find out whether there is a tile in a given position on a given layer. If there is a tile, then we get its ID:</p> <pre><code>    render() {\n        for (let layer = 0; layer &lt; App.config.level.layers; layer++) {\n            let index = 0;\n            const layerData = json.layers[layer];\n            this.tiles[layerData.name] = [];\n\n            if (layerData.data) {\n                for (let row = 0; row &lt; App.config.level.rows; row++) {\n                    for (let col = 0; col &lt; App.config.level.cols; col++) {\n                        const tileId = TilemapJson.layers[layer].data[index];\n                        index++;\n                        if (tileId) {\n                            const tile = this.renderTile(tileId, row, col);\n                            this.tiles[layerData.name].push(tile);\n\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n}\n</code></pre> <p>If we found the tile ID at a given position, we can draw it:</p> <pre><code>    renderTile(id, row, col) {\n        let tile = new Tile(id);\n        tile.sprite.x = col * App.config.level.tileSize;\n        tile.sprite.y = row * App.config.level.tileSize;\n        tile.sprite.width = App.config.level.tileSize;\n        tile.sprite.height = App.config.level.tileSize;\n        this.container.addChild(tile.sprite);\n        return tile;\n    }\n</code></pre> <p>When drawing, we use the tile sizes that we want to get in the game. That is, we take data from the <code>tileSize</code> field of the <code>level</code> object, and not from the <code>map</code>. In our case, it is 32px. Taking these dimensions into account, we create the tile in the correct position on the screen with the correct offset. And add the created tile to the container of the <code>LevelMap</code> class.</p> <p>Now we can render the entire map in the <code>Game</code> scene:</p> <pre><code>import { Scene } from '../system/Scene';\nimport { LevelMap } from './LevelMap';\n\nexport class GameScene extends Scene {\n    create() {\n        this.createMap();\n    }\n    createMap() {\n        this.map = new LevelMap();\n        this.container.addChild(this.map.container);\n    }\n}\n</code></pre> <p>It is easy to calculate that a grid size of 18x32 taking into account the tile size of 32px will give us a map of 1024 x 576 pixels.</p> <p>Let's specify this data when creating the pixi canvas in the <code>App</code> class:</p> <pre><code>        this.app = new PIXI.Application({ width: 1024, height: 576});\n        this.app.view.style = `width: 1024px; height: 576;`;\n</code></pre> <p>And now let\u2019s check whether the map is displayed correctly on the screen.</p>"},{"location":"tower-defense/#3-creating-the-enemy","title":"3. Creating the enemy","text":""},{"location":"tower-defense/#31-enemy-sprite","title":"3.1 Enemy sprite","text":"<p>Let's create a single enemy in a random location on the map. We know that enemies tiles are also included in the general atlas <code>tilemap.png</code>. Each enemy tile has its own frame number in the atlas. Let's add this data to the general game config:</p> <pre><code>export const Config = {\n    // ...\n    enemies: {\n        \"unit1\": {\n            \"id\": 246,\n            \"coins\": 20,\n            \"velocity\": 75,\n            \"hp\": 1\n        },\n        \"unit2\": {\n            \"id\": 247,\n            \"coins\": 30,\n            \"velocity\": 100,\n            \"hp\": 2\n        },\n        \"unit3\": {\n            \"id\": 248,\n            \"coins\": 40,\n            \"velocity\": 125,\n            \"hp\": 3\n        },\n        \"unit4\": {\n            \"id\": 249,\n            \"coins\": 50,\n            \"velocity\": 150,\n            \"hp\": 4\n        }\n    }\n};\n</code></pre> <p>Thus, each enemy unit receives its own config, which distinguishes it from all other units. In this case, we set the following parameters in the config of each unit: - frame id in tilemap - movement speed - health - the reward amount for killing</p> <p>To render one tile, which is the atlas frame, we have previously developed the <code>Tile</code> class. Since the image of an enemy is also a tile, we can create the <code>Enemy</code> class, which will be a child of a <code>Tile</code> class. All we need to do is pass the correct frame index to the constructor of the <code>Tile</code> base class. And now we can get these numbers from the config:</p> <p><pre><code>import { Tile } from \"./Tile\";\nimport { App } from \"../system/App\";\n\nexport class Enemy extends Tile {\n    constructor(config, path) {\n        super(config.id);\n        this.config = config;\n        this.sprite.anchor.set(0.5);\n    }\n}\n</code></pre> Thus, we pass the config of the enemy unit to the constructor of the <code>Enemy</code> class. Using the id from the config, we get the required tile. We save the unit config in the <code>this.config</code> field for further receiving special unit parameters.</p> <p>Now let's create an enemy in a random location on the map in the <code>Game</code> class:</p> <pre><code>// ...\nimport { Enemy } from './Enemy';\n\nexport class GameScene extends Scene {\n    create() {\n        this.createMap();\n        this.createEnemies();\n    }\n    createEnemies() {\n        const enemy = new Enemy(App.config.enemies.unit1);\n        this.container.addChild(enemy.sprite);\n        enemy.sprite.x = 130;\n        enemy.sprite.y = 530;\n    }\n    // ...\n}\n</code></pre>"},{"location":"tower-defense/#32-enemy-movement","title":"3.2 Enemy movement","text":"<p>Now let's implement the movement of the newly created enemy. The enemy should be moving along the road on our level map. When we created our map in <code>Tiled</code>, we set special points on the road that indicates the direction of the enemies. These points are markers through which enemies must pass, moving from one point to the next and so on until they reach the last one. We placed such marks on a separate special layer of our tilemap, which is called <code>path</code>. There is no <code>data</code> field in this layer, since there are no tiles on it. Instead, on this layer in the <code>objects</code> field there are points with map coordinates. Let's put this data in the <code>this.path</code> field of the <code>LevelMap</code> class:</p> <p><pre><code>//...\nexport class LevelMap {\n    constructor() {\n        // ...\n        this.path = {};\n    }\n\n    render() {\n        //...\n        if (layerData.data) {\n            //...\n        } else if (layerData.objects) {\n            this.path = layerData.objects;\n        }\n    }\n}\n</code></pre> When creating an enemy, we must let him know about the points on the map through which he must pass. That is, we will pass the <code>path</code> field of the map object to the enemy object:</p> <p><pre><code>// ...\nexport class GameScene extends Scene {\n    //...\n    createEnemies() {\n        const enemy = new Enemy(App.config.enemies.unit1, this.map.path);\n        // ...\n        enemy.move();\n    }\n}\n</code></pre> Here we also immediately called the <code>move</code> method, which should start an animation of the enemy moving around the map. Now let's implement this method in the <code>Enemy</code> class.</p> <ol> <li>Save the <code>path</code> object of the map in a <code>this.path</code> field of the <code>Enemy</code> class.</li> <li>Add the index number of the current point: the <code>pathIndex</code> field will show which point the enemy passed last.</li> </ol> <p><pre><code>//...\nexport class Enemy extends Tile {\n\n    constructor(config, path) {\n        super(config.id);\n        this.config = config;\n        this.sprite.anchor.set(0.5);\n        this.pathIndex = 1;\n        this.path = path;\n    }\n    //...\n}\n</code></pre> The <code>getNextPoint</code> method will return the enemy's current target based on the number of the point the enemy last passed. So, knowing the number of the point that the enemy just passed, he can get the next point to move to in the movement animation:</p> <p><pre><code>    //...\n    getNextPoint() {\n        const nextPoint = this.pathIndex + 1;\n\n        return this.path.find(point =&gt; point.name === nextPoint.toString());\n    }\n    //...\n</code></pre> Now we can fully implement the <code>move</code> method, which will launch an animation of the enemy moving between points. To do this, we need to develop the following algorithm:</p> <ol> <li>Get the next point to move to</li> <li>Increase the value of the <code>pathIndex</code> field, indicating the next point passed</li> <li>Get the current coordinates of the enemy sprite</li> <li>Get the coordinates of the target to which you want to move</li> <li>Calculate the distance between the target and the current position of the enemy</li> <li>Calculate the duration of the movement based on the distance traveled and the speed taken from the unit config</li> <li>Run a motion animation using <code>gsap</code></li> <li>When the motion animation is finished, restart the <code>move</code> method to start moving to the next point</li> </ol> <p>Let's implement this algorithm:</p> <pre><code>    move() {\n        // get the next point\n        const point = this.getNextPoint();\n        if (!point) {\n            // if there is no such thing, then there is nowhere to move\n            return;\n        }\n        //increase the index of the last point passed\n        ++this.pathIndex;\n\n        // current coordinates\n        const sourceX = this.sprite.x;\n        const sourceY = this.sprite.y;\n\n        // target coordinates\n        const targetX = point.x / 2;\n        const targetY = point.y / 2;\n\n        // distance between target and current position\n        const diffX = Math.abs(targetX - sourceX);\n        const diffY = Math.abs(targetY - sourceY);\n        const diff = Math.max(diffX, diffY);\n\n        // duration of movement\n        const duration = diff / this.config.velocity;\n\n        // movement animation\n        gsap.to(this.sprite, {\n            onComplete: () =&gt; {\n                // repeat the process for the next point\n                this.move();\n            },\n            pixi: { x: point.x / 2, y: point.y / 2 },\n            duration,\n            ease: \"none\",\n          });\n\n    }\n}\n</code></pre>"},{"location":"tower-defense/#33-setting-the-angle","title":"3.3 Setting the angle","text":"<p>Now our enemy is really moving across the entire map from point to point, but he is always facing the same direction. Let's fix this. Let's make sure that the enemy always faces towards the next point on his path.</p> <p>To do this, we need the <code>getAngle</code> method, which, based on the coordinates of the target point, will return the angle by which the enemy sprite needs to be rotated. You can get the angle using the function  <code>Math.atan2</code>:</p> <p>Math.atan2</p> <p>The Math.atan2() static method returns the angle in the plane (in radians) between the positive x-axis and the ray from (0, 0) to the point (x, y), for Math.atan2(y, x).</p> <p>Since this method returns the angle in radians, let's convert it to degrees:</p> <pre><code>// Enemy.js\ngetAngle(target) {\n    const sourceX = this.sprite.x;\n    const sourceY = this.sprite.y;\n\n    const dy = target.y - sourceY;\n    const dx = target.x - sourceX;\n    return 180 * Math.atan2(dy, dx) / Math.PI; \n}\n</code></pre> <p>Now we can call this angle in the move method before starting the motion animation:</p> <pre><code>// Enemy.js\nmove() {\n    //...\n    this.sprite.angle = this.getAngle({x: targetX, y: targetY});\n}\n</code></pre>"},{"location":"tower-defense/#4-waves-of-enemies","title":"4. Waves of enemies","text":"<p>We have successfully created a single enemy that moves along the map. There will be 4 waves of enemies in our game. Each wave will have a given number of units of a certain type. Let's start by setting the enemies waves config:</p> <pre><code>export const Config = {\n    // ...\n    enemiesWaves: [{\n        count: 8,\n        type: \"unit1\"\n    }, {\n        count: 12,\n        type: \"unit2\"\n    }, {\n        count: 16,\n        type: \"unit3\"\n    }, {\n        count: 20,\n        type: \"unit4\"\n    }]\n}\n</code></pre> <p>Now we can develop a class that will manage the creation of enemy waves. Let's create the <code>Enemies.js</code> class:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { EventEmitter } from \"events\";\nimport { App } from '../system/App';\nimport { Enemy } from \"./Enemy\";\n\nexport class Enemies extends EventEmitter {\n\n    constructor(map) {\n        super();\n\n        this.container = new PIXI.Container();\n        this.map = map;\n        this.units = [];\n        this.config = App.config.enemiesWaves;\n        this.index = 0;\n        this.create();\n    }\n\n    createEnemy(i, type) {}\n    create() {}\n}\n</code></pre> <ul> <li>In the constructor we created a container in which we will place all the created enemy sprites.</li> <li>We write the level map object to the internal field <code>this.map</code>.</li> <li>In the <code>this.units</code> field we will store all created objects of the <code>Enemy</code> class.</li> <li>In the <code>this.config</code> field we set data about all planned waves of enemies from the config.</li> <li>The <code>this.index</code> field indicates the index of the current wave.</li> </ul> <p>And the <code>create</code> method will create a new wave based on the current index. Let's develop it:</p> <pre><code>    create() {\n        const config = this.config[this.index];\n\n        if (!config) {\n            return;\n        }\n\n        ++this.index;\n\n        for (let i = 0; i &lt; config.count; i++) {\n            this.createEnemy(i, config.type);\n        }\n    }\n</code></pre> <p>Here we get the config of the desired wave according to the current index. And we create the required number of enemies in a loop in the <code>createEnemy</code> method. We can move the enemy creation code from <code>Game.createEnemies</code> into the <code>Enemies.createEnemy</code> method. We need to perform 3 steps:</p> <ol> <li>Create an enemy object and save it in an <code>Enemies</code> class object.</li> <li>Place the created object at the starting point on the map</li> <li>Start the movement of the enemy object</li> </ol> <p>Let's do these steps:</p> <pre><code>// Enemies.js\n// ...\ncreateEnemy(i, type) {\n    // create a new enemy\n    const enemy = new Enemy(App.config.enemies[type], this.map.path);\n    enemy.sprite.anchor.set(0.5);\n    this.container.addChild(enemy.sprite);\n    this.units.push(enemy);\n\n    // place it at the starting position on the map\n    const start = this.map.path.find(point =&gt; point.name === \"1\");\n    enemy.sprite.x = start.x / 2;\n    enemy.sprite.y = start.y / 2;\n\n    // start the enemy's movement with a given delay\n    window.setTimeout(enemy.move.bind(enemy), this.enemyDelay * i);\n}\n</code></pre> <p>Let's add the <code>this.enemyDelay</code> field to the <code>Enemies</code> class constructor:</p> <pre><code>const EnemyDelay = 1000;\n\nexport class Enemies extends EventEmitter {\n\n    constructor(map) {\n        // ...\n        this.enemyDelay = EnemyDelay;\n    }\n    // ...\n}\n</code></pre> <p>Now in the <code>Game</code> class we will rewrite the <code>createEnemies</code> method and create an <code>Enemies</code> class object in it to create a wave of opponents:</p> <pre><code>// Game.js\n// ...\ncreateEnemies() {\n    this.enemies = new Enemies(this.map);\n    this.container.addChild(this.enemies.container);\n}\n</code></pre>"},{"location":"tower-defense/#5-creating-a-tower","title":"5. Creating a tower","text":"<p>Now we have enemies in the level, which means it's time to create towers that will shoot at these enemies. </p>"},{"location":"tower-defense/#51-tower-place","title":"5.1 Tower place","text":"<p>On our map we have special places where we can build a tower. We defined such places as special tiles in <code>tilemap</code> on a separate layer called <code>towers</code>. </p> <p>Let's explicitly list which tiles are places for the tower. Tilemap frames with serial numbers <code>42</code> and <code>111</code> are tiles of tower locations. For such tiles, we will specify a special class in the config, which will be a child of the <code>Tile</code> class:</p> <pre><code>export const Config = {\n    // ...\n    tiles: {\n        42: TowerPlace,\n        111: TowerPlace\n    }\n}\n</code></pre> <p>Now let's create the <code>TowerPlace</code> class:</p> <p><pre><code>import { App } from \"../system/App\";\nimport { Tile } from \"./Tile\";\n\nexport class TowerPlace extends Tile {\n\n    constructor(id) {\n        super(id)\n        this.level = 0;\n        this.sprite.interactive = true;\n        this.sprite.once(\"pointerdown\", this.onClick, this);\n        this.tower = null;\n    }\n\n    onClick() {\n        App.emit(\"tower-place-click\", this);\n    }\n}\n</code></pre> We will pass the tile id to the constructor of this class. </p> <p>The <code>this.level</code> field will indicate what level the tower is currently built at this location. Accordingly, <code>this.level = 0;</code> means that there is currently no tower at this place.</p> <p>The <code>this.tower</code> property will store the object of the tower built at that place.</p> <p>The main task of the <code>TowerPlace</code> class will be to track the click event on such a tile and fire the event by the application class.</p> <p>Let's extend <code>Application</code> class from the <code>EventEmitter</code> class of the <code>events</code> library to be able to emit and listen for the events:</p> <pre><code>import { EventEmitter } from \"events\";\n\nclass Application extends EventEmitter {\n    // ...\n}\n</code></pre> <p>Now, when creating tiles in the <code>LevelMap</code> class, we somehow need to check which class needs to be created for the current tile: base class <code>Tile</code> or special class <code>TowerPlace</code>, if the current tile is specified by one of the identifiers specified earlier in the config. A factory pattern is the best option for this task.</p> <p>Let's create the <code>TileFactory</code> class. In this class we implement the static method <code>create</code>. In this method we will take the id of the tile as a parameter. If for a given tile id a special class is specified in the game config, then we will create an instance of this class. Otherwise, let's create an instance of the base class <code>Tile</code>:</p> <pre><code>import { App } from \"../system/App\";\nimport { Tile } from \"./Tile\";\n\nexport class TileFactory {\n\n    static create(id) {\n        const tileClass = App.config.tiles[id];\n\n        if (tileClass) {\n            return new tileClass(id);\n        }\n\n        return new Tile(id);\n    }\n}\n</code></pre> <p>Now let's update the first line of code in the <code>LevelMap.renderTile</code> method so that instead of directly creating a base <code>Tile</code> class, we use a factory:</p> <pre><code>renderTile(id, row, col) {\n    const tile = TileFactory.create(id);\n    // ...\n}\n</code></pre> <p>And finally, in the <code>Game</code> class we will add an event handler for the tower's place click:</p> <pre><code>export class GameScene extends Scene {\n    create() {\n        // ...\n        this.setEvents();\n    }\n\n    setEvents() {\n        App.on(\"tower-place-click\", this.onTowerPlaceClick.bind(this));\n    }\n\n    onTowerPlaceClick(towerPlace) {\n        console.log(\"tower place click\", towerPlace);\n    }\n</code></pre>"},{"location":"tower-defense/#52-tower-construction","title":"5.2 Tower construction","text":"<p>Towers are represented by tiles with serial numbers <code>250</code> and <code>251</code>. Let's add this data to the game config:</p> <p><pre><code>export const Config = {\n    // ...\n    towers: {\n        \"tower1\": {\n            \"id\": 250,\n            \"range\": 300,\n            \"coins\": 100,\n            \"cooldown\": 1000,\n            \"bullet\": {\n                \"speed\": 10,\n                \"damage\": 1\n            }\n        },\n        \"tower2\": {\n            \"id\": 251,\n            \"range\": 400,\n            \"coins\": 200,\n            \"cooldown\": 500,\n            \"bullet\": {\n                \"speed\": 15,\n                \"damage\": 2\n            }\n        }\n    }\n}\n</code></pre> In addition, we added all the necessary data for each tower: - <code>coins</code> - construction cost - <code>range</code> - radius of the coverage area - <code>cooldown</code> - reloading time - <code>bullet</code> - speed and damage from tower's bullets</p> <p>Let's inherit the <code>Tower</code> class from the <code>Tile</code> class:</p> <p><pre><code>import { Tile } from \"./Tile\";\n\nexport class Tower extends Tile {\n    constructor(config) {\n        super(config.id);\n        this.config = config;\n        this.place = null;\n        this.active = false;\n    }\n}\n</code></pre> We will pass the config of the current tower as a parameter to the constructor of the <code>Tower</code> class. In addition, we will set the <code>this.place</code> field, in which we will place a <code>towerPlace</code> object. We also added <code>this.active</code> flag, indicating that this tower can fire at the moment and is not in reloading mode.</p> <p>Now we can build the tower. Each click on a tower place tile will build a higher level tower on that place. To implement the tower construction functionality, we have the <code>Game.onTowerPlaceClick</code> method. And to build a tower we must do the following:</p> <ol> <li>Increase the tower level for selected <code>towerPlace</code> object.</li> <li>Find a tower in the config with the same level as the selected <code>towerPlace</code> object.</li> <li>If there is such a tower, create a new tower object and save it in the <code>towerPlace</code> object. </li> <li>If a tower has already been built in a given place, then destroy its sprite.</li> </ol> <pre><code>onTowerPlaceClick(towerPlace) {\n    ++towerPlace.level;\n\n    const towerConfig = App.config.towers[\"tower\" + towerPlace.level];\n\n    if (towerConfig) {\n        if (towerPlace.tower) {\n            towerPlace.tower.sprite.destroy();\n        }\n\n        const tower = new Tower(towerConfig);\n        towerPlace.tower = tower;\n        tower.place = towerPlace;\n        towerPlace.sprite.addChild(tower.sprite);\n    }\n}\n</code></pre> <p>Having built the tower, we will save a reference to it in the <code>towerPlace</code> object, and also save a reference to the <code>towerPlace</code> object in the <code>tower</code> itself. To display the tower on the level map, add a tower tile sprite as a child of the tower place sprite.</p>"},{"location":"tower-defense/#6-preparation-for-shooting","title":"6. Preparation for shooting","text":"<p>Now that there are both enemies and towers in the game, we can move on to creating the functionality for shooting at enemies.</p>"},{"location":"tower-defense/#61-tower-coverage","title":"6.1 Tower coverage","text":"<p>How will the tower attack the enemy?</p> <p>First, the enemy must get into the tower's firing range. If enemies enter such a zone, the tower will be able to detect them and begin attack. We have already set the range of the firing zone in the tower config. Since a zone is a circle with a given radius, we can use the class PIXI.Graphics to draw such a circle.</p> <p>Let's create a fire zone in the <code>Tower</code> class. Draw a circle with a given radius in a tower global coordinates using PIXI.Graphics.</p> <pre><code>export class Tower extends Tile {\n    // ...\n    createArea() {\n        this.area = new PIXI.Graphics();\n        this.area.beginFill(0xffffff, 1);\n        this.area.drawCircle(this.sprite.getGlobalPosition().x, this.sprite.getGlobalPosition().y, this.config.range);\n        this.area.endFill();\n    }\n}\n</code></pre> <p>Next, call this method in the <code>Game</code> class when creating a tower:</p> <pre><code>export class GameScene extends Scene {\n    create() {\n        this.createCollisionsContainer();\n        // ...\n    }\n\n    createCollisionsContainer() {\n        this.collisions = new PIXI.Container();\n        this.container.addChild(this.collisions);\n    }\n\n    onTowerPlaceClick(towerPlace) {\n        // ...\n        tower.createArea();\n        this.collisions.addChild(tower.area);\n    }\n</code></pre> <p>We will also need a separate <code>this.collisions</code> container in the <code>Game</code> class, which we will create at the very beginning and add it as the very first children for the <code>Game</code> container. We will add all created tower zones as child elements to this container. We do this in order to hide the zone images themselves under the map layer.</p>"},{"location":"tower-defense/#62-enemy-detection","title":"6.2 Enemy Detection","text":"<p>Now we can check that the enemy is in the created firing zone.</p> <p>First, let's implement the <code>Tower.detect</code> method:</p> <pre><code>detect(enemy) {\n    if (enemy.sprite) {\n        return this.area.containsPoint(new PIXI.Point(enemy.sprite.x, enemy.sprite.y));\n    }\n    return false;\n}\n</code></pre> <p>Here we use the containsPoint method of the PIXI.Graphics, passing it the enemy coordinates as a parameter and thus checking whether these coordinates belong to the current zone or not.</p> <p>We must call this method constantly throughout the game to check the visibility of opponents in real time.</p> <p>To do this, in the <code>Game</code> class we will use the capabilities of (PIXI.Ticker)[https://pixijs.download/v7.0.5/docs/PIXI.Ticker.html] to constantly call the <code>update</code> method on each new animation frame:</p> <pre><code>    setEvents() {\n        App.on(\"tower-place-click\", this.onTowerPlaceClick.bind(this));\n        App.app.ticker.add(this.update, this);\n    }\n\n    update() {\n    }\n</code></pre> <p>Let's write down the algorithm of actions we need in this method to check the detection of opponents by towers:</p> <ul> <li>for each tower created at the level<ul> <li>find the first unit that fell into the tower\u2019s fire zone<ul> <li>if such a unit is found, we attack it</li> </ul> </li> </ul> </li> </ul> <p>Now let's implement this algorithm in the <code>processTowerAttackEnemies</code> method in the <code>Game</code> class and call this methid in the <code>update</code>:</p> <pre><code>    processTowerAttackEnemies() {\n        this.map.towers.forEach(tower =&gt; {\n            const enemy = this.enemies.units.find(unit =&gt; tower.detect(unit));\n\n            if (enemy) {\n                tower.attack(enemy);\n            }\n        });\n    }\n\n    update() {\n        this.processTowerAttackEnemies();\n    }\n</code></pre> <p>We will implement the attack itself in the following lessons. For now, let's leave the <code>Tower.attack</code> method empty: <pre><code>// Tower.js\nattack() {}\n</code></pre> Currently we get all created towers from the <code>this.map.towers</code> object. This means we need to implement this getter in the <code>LevelMap</code> class. Getting all created towers is simple:</p> <ul> <li>get all the tiles from the towers layer - these are places for towers:</li> </ul> <pre><code>const towerPlaces = this.tiles[\"towers\"];\n</code></pre> <ul> <li>filter out those places where the towers are actually built:</li> </ul> <pre><code>const towerPlacesWithTowers = towerPlaces.filter(towerPlace =&gt; towerPlace.tower);\n</code></pre> <ul> <li>get the towers with the <code>Array.prototype.map</code> function:</li> </ul> <pre><code>towerPlacesWithTowers.map(towerPlace =&gt; towerPlace.tower);\n</code></pre> <p>As a result, all these actions can be written in one line:</p> <pre><code>    get towers() {\n        return this.tiles[\"towers\"].filter(towerPlace =&gt; towerPlace.tower).map(towerPlace =&gt; towerPlace.tower);\n    }\n</code></pre>"},{"location":"tower-defense/#63-tower-rotation","title":"6.3 Tower rotation","text":"<p>Let's turn the tower towards the enemy we need to shoot at. To do this, we need to get the angle by which we want to rotate the tower sprite. We have already done a similar mechanism in the <code>Enemy</code> class, when we implemented a unit turn towards the next point on its path. Let's move this code into the <code>Tower</code> class:</p> <pre><code>    getAngleByTarget(targetPosition) {\n        const x = targetPosition.x - this.sprite.parent.x;\n        const y = targetPosition.y - this.sprite.parent.y;\n        return 180 * Math.atan2(y, x) / Math.PI + 90;\n    }\n\n    rotateToEnemy(enemy) {\n        this.sprite.angle = this.getAngleByTarget({x: enemy.sprite.x, y: enemy.sprite.y});\n    }\n</code></pre> <p>Since the tower sprite is a child sprite of the tower place tile, we must get the coordinates of the tower place tile as coordinates. Therefore, in this case we get the source coordinates from the parent sprite: - <code>this.sprite.parent.x</code> - <code>this.sprite.parent.y</code></p> <p>Please note that in our atlas <code>tilemap.png</code> the tower tiles are rotated 90 degrees relative to the unit tiles. Therefore, we add 90 degrees to the resulting value before returning the result of the <code>getAngleByTarget</code> function.</p> <p>Let's modify <code>attack</code> method in the <code>Tower</code> class:</p> <pre><code>// Tower.js\nattack(enemy) {\n    this.rotateToEnemy(enemy);\n}\n</code></pre>"},{"location":"tower-defense/#7-shooting","title":"7. Shooting","text":""},{"location":"tower-defense/#71-creating-a-bullet","title":"7.1 Creating a bullet","text":"<p>The towers will shoot bullets at enemies. The bullet in our game is represented by the <code>fire.png</code> sprite. Let's create a <code>Bullet</code> class that will create a bullet for a given tower:</p> <pre><code>import { EventEmitter } from \"events\";\nimport { App } from '../system/App';\n\nexport class Bullet extends EventEmitter {\n    constructor(tower, enemy) {\n        super();\n        this.tower = tower;\n        this.enemy = enemy;\n\n        this.sprite = App.sprite(\"fire\");\n        this.sprite.anchor.set(0.5, 1);\n        this.sprite.x = this.tower.sprite.x;\n        this.sprite.y = this.tower.sprite.y;\n\n        this.sprite.angle = this.tower.sprite.angle;\n    }\n}\n</code></pre> <p>Let's extend this class from the <code>EventEmitter</code> class to be able to send bullet events. For example, in the future we will need to know about the moment when a bullet is destroyed (either when it hits an enemy or when it goes off the edge of the screen), at which we will trigger the corresponding event.</p> <p>Let's pass into the <code>Bullet</code> constructor the objects of the tower from which the shooting is made, as well as the enemy at whom the bullet was fired.</p> <p>Let's create a bullet sprite and place it in the coordinates of the tower at the same angle as the tower.</p> <p>The <code>shoot</code> method in the <code>Tower</code> class will be responsible for the shooting itself. In this method we need to create an instance of the <code>Bullet</code> class:</p> <p><pre><code>export class Tower extends Tile {\n    constructor(config) {\n        // ...\n        this.bullets = [];\n        this.active = true;\n    }\n    // ...\n    shoot(enemy) {\n        const bullet = new Bullet(this, enemy);\n        this.bullets.push(bullet);\n        this.sprite.parent.addChild(bullet.sprite);\n    }\n}\n</code></pre> This method also takes as a parameter the enemy object that the tower is firing at. In addition, we will put all the bullets created in the <code>this.bullets</code> field so that we can track each bullet created later and check if it collided with any enemy.</p> <p>Now let's modify the <code>attack</code> method in the <code>Tower</code> class by adding a call of the <code>shoot</code> method, making sure the tower is active:</p> <pre><code>    attack(enemy) {\n        this.rotateToEnemy(enemy);\n\n        if (this.active) {\n            this.active = false;\n            this.shoot(enemy);\n            window.setTimeout(() =&gt; this.active = true, this.config.cooldown);\n        }\n    }\n</code></pre> <p>We used an <code>active</code> flag to indicate whether the turret can fire at the moment. The fact is that we are calling the <code>Tower.attack</code> method in the <code>Game.update</code> method, which in turn is called constantly for each new animation frame. But we want to fire bullets only at a given frequency for a given tower. </p> <p>Therefore, in order to implement the cooldown time, we need to turn off the tower activity immediately after the shot and then turn it on after a given timeout. Then we start a timeout with the reload time specified from the tower config, after which we activate the tower again by setting the flag <code>this.active = true;</code></p>"},{"location":"tower-defense/#72-firing-a-bullet","title":"7.2 Firing a bullet","text":"<p>To make a bullet move, we need to update the coordinates of the bullet sprite by a given offset every frame of the animation. To do this, we need to determine the correct offset along the <code>x</code> and <code>y</code> axes, taking into account the angle by which the bullet sprite is rotated. Let's do this in the <code>Bullet.init</code> method:</p> <p><pre><code>export class Bullet extends EventEmitter {\n    constructor(tower, enemy) {\n        // ...\n        this.init();\n    }\n\n    init() {\n        const speed = this.tower.config.bullet.speed;\n        const azimuth = (this.sprite.angle) * (Math.PI / 180) - Math.PI / 2;\n        this.velocity = {x: Math.cos(azimuth) * speed, y: Math.sin(azimuth) * speed};\n        App.app.ticker.add(this.update, this);\n    }\n\n    update() {\n        this.sprite.x += this.velocity.x;\n        this.sprite.y += this.velocity.y;\n    }\n}\n</code></pre> Here we take the bullet speed from the tower config that we set earlier. Next, we determine the azimuth based on the angle at which the bullet sprite is rotated after its creation. Knowing the azimuth and speed, we can calculate the the bullet's offset along the <code>x</code> and <code>y</code> axes. Let's write the offset in the <code>this.velocity</code> field.</p> <p>And finally, we create a callback function <code>update</code>, in which we assign the resulting offset to the coordinates of the bullet sprite. </p> <p>And let's add this function to the PIXI.Ticker so that it runs for every frame of the game animation.</p>"},{"location":"tower-defense/#73-destruction-of-a-bullet","title":"7.3 Destruction of a bullet","text":"<p>If the bullet goes beyond the screen, it must be destroyed for 2 reasons:</p> <ol> <li>an object that is no longer used should not take up memory space</li> <li>checks that are no longer required should not be performed and the bullet's <code>update</code> method should not continue to be called, performing unnecessary calculations</li> </ol> <p>Let's do this right away in order to immediately avoid possible problems with the game's performance.</p> <p>Let's check the coordinates of the bullet and, if the bullet has gone beyond the screen, destroy the sprite and remove the <code>update</code> method from the ticker:</p> <pre><code>    update() {\n        this.sprite.x += this.velocity.x;\n        this.sprite.y += this.velocity.y;\n\n        let position = this.sprite.getGlobalPosition()\n\n        if (position.x &lt; 0 || position.x &gt; App.app.view.width) {\n            this.remove();\n        }\n    }\n\n    remove() {\n        App.app.ticker.remove(this.update, this);\n        this.sprite.destroy();\n        this.sprite = null;\n        this.emit(\"removed\");\n    }\n</code></pre> <p>We only need to check the <code>x</code> coordinate of the bullet sprite. To get the global position of the bullet on the screen, use the method PIXI.Sprite <code>getGlobalPosition</code> We know that the left edge of the screen has an <code>x</code> coordinate equal to <code>0</code>. The coordinate of the right edge of the screen can be obtained by finding out the width of the <code>canvas</code> by calling <code>App.app.view.width</code>. If the <code>x</code> coordinate of the bullet is less than <code>0</code> or greater than the coordinate of the right edge of the screen, destroy the bullet sprite, remove the callback from the ticker and fire the corresponding event.</p> <p>Now that we can track the bullet's destruction event, we'll modify the <code>Tower.shoot</code> method and remove the destroyed bullet from the tower's bullet pool:</p> <pre><code>shoot(enemy) {\n    // ...\n    bullet.once(\"removed\", () =&gt; this.bullets = this.bullets.filter(item =&gt; item !== bullet));\n}\n</code></pre>"},{"location":"tower-defense/#8-enemy-damage","title":"8 Enemy damage","text":""},{"location":"tower-defense/#81-collision-with-a-bullet","title":"8.1 Collision with a bullet","text":"<p>If the bullet sprite comes into contact with the enemy sprite, it is necessary to destroy the bullet and apply damage to the enemy unit. Let's start by tracking sprite collisions.</p> <p>In the new <code>processEnemyBulletCollision</code> method, we will loop through all the bullets of each tower and for each bullet we will check if there is at least one enemy that this bullet collided with:</p> <pre><code>    processEnemyBulletCollision() {\n        this.map.towers.forEach(tower =&gt; {\n            tower.bullets.forEach(bullet =&gt; {\n                const enemy = this.enemies.units.find(unit =&gt; bullet.collide(unit.sprite));\n\n                if (enemy) {\n                    bullet.remove();\n                }\n            });\n        });\n    }\n\n    update() {\n        // ...\n        this.processEnemyBulletCollision();\n    }\n</code></pre> <p>Let's develop the <code>collide</code> method in the <code>Bullet</code> class:</p> <pre><code>collide(sprite) {\n    if (!sprite) {\n        return;\n    }\n    return sprite.containsPoint(this.sprite.getGlobalPosition());\n}\n</code></pre>"},{"location":"tower-defense/#82-applying-damage","title":"8.2 Applying Damage","text":"<p>Let's apply bullet damage to the enemy before destroying the bullet:</p> <pre><code>    processEnemyBulletCollision() {\n        // ...\n        if (bullet.collide(enemy.sprite)) {\n            enemy.addDamage(bullet.damage);\n            bullet.remove();\n        }\n        // ...\n    }\n</code></pre> <p>Let's set the <code>damage</code> field in the <code>Bullet</code> class with the value from the config:</p> <pre><code>export class Bullet extends EventEmitter {\n    constructor(tower, enemy) {\n        // ...\n        this.damage = this.tower.config.bullet.damage;\n    }\n}\n// ...\n</code></pre> <p>Let's implement the <code>addDamage</code> and <code>remove</code> methods in the <code>Enemy</code> class:</p> <p><pre><code>export class Enemy extends Tile {\n\n    constructor(config, path) {\n        // ...\n        this.hp = this.config.hp;\n    }\n    // ...\n\n    addDamage(damage) {\n        this.hp -= damage;\n\n        if (this.hp &lt;= 0) {\n            this.remove();\n        }\n    }\n\n    remove() {\n        gsap.killTweensOf(this.sprite);\n        this.sprite.destroy();\n        this.sprite = null;\n        this.emit(\"removed\");\n    }\n}\n</code></pre> Let's set the health value from the enemy config. In the <code>addDamage</code> method we subtract the required amount of health and, if the value is less than or equal to zero, call the <code>remove</code> method.</p> <p>In the <code>remove</code> method, first of all, we need to stop the animation of the <code>gsap</code> tweens. Then we destroy the sprite and fire the <code>removed</code> event:</p> <p>Let's subscribe to this event in the <code>Enemies</code> class immediately after creating the unit. Therefore, we will remove the unit from the active units pool when the event occurs:</p> <pre><code>createEnemy(i) {\n    // ...\n    enemy.once(\"removed\", this.onEnemyRemoved.bind(this, enemy));\n}\n\nonEnemyRemoved(enemy) {\n    this.units = this.units.filter(unit =&gt; unit !== enemy);\n\n    if (!this.units.length) {\n        window.setTimeout(this.create.bind(this), this.waveDelay);\n    }\n}\n</code></pre> <p>After deleting a unit, we additionally check the size of <code>this.units</code> field. If there are no units left in it, then it\u2019s time to create a new enemies wave by calling the <code>create</code> method with a given delay. And let's add the <code>this.waveDelay</code> field to the <code>Enemies</code> class constructor:</p> <pre><code>const WaveDelay = 3000;\n\nexport class Enemies extends EventEmitter {\n\n    constructor(map) {\n        // ...\n        this.waveDelay = WaveDelay;\n    }\n    // ...\n}\n</code></pre>"},{"location":"tower-defense/#9-player","title":"9. Player","text":"<p>The player class will store information about the available number of coins and the number of lives remaining:</p> <pre><code>import { App } from \"../system/App\";\n\nexport class Player {\n    constructor() {\n        this.coins = App.config.player.coins;\n        this.lives = App.config.player.lives;\n    }\n}\n</code></pre> <p>We will write the initial values \u200b\u200bin the config:</p> <pre><code>export const Config = {\n    // ...\n    player: {\n        coins: 200,\n        lives: 5\n    }\n};\n</code></pre> <p>Let's create a player in the <code>Game</code> class:</p> <pre><code>import { Player } from './Player';\n\nexport class GameScene extends Scene {\n    create() {\n        this.createPlayer();\n        // ...\n    }\n\n    createPlayer() {\n        this.player = new Player();\n    }\n    // ...\n}\n</code></pre>"},{"location":"tower-defense/#10-ui","title":"10. UI","text":"<p>Now that we have data about the player's available coins and lives, we can display it on the screen. Our <code>UI</code> will consist of the following elements:</p> <ul> <li>lives icon - sprite <code>heart.png</code></li> <li>coin icon - sprite <code>coin.png</code></li> <li>text with the number of coins</li> <li>text with the number of lives</li> </ul> <p>So let's create the <code>UI</code> class with the listed elements:</p> <pre><code>import * as PIXI from \"pixi.js\";\nimport { App } from \"../system/App\";\n\nexport class UI {\n    constructor(player) {\n        this.player = player;\n        this.container = new PIXI.Container();\n        this.config = App.config.ui;\n        this.create();\n        this.update();\n    }\n\n    createCoinsIcon() {\n        this.coins = App.sprite(\"coin\");\n        this.coins.anchor.set(0.5);\n        this.coins.x = this.config.coinsIcon.x;\n        this.coins.y = this.config.coinsIcon.y;\n        this.container.addChild(this.coins);\n    }\n\n    createLivesIcon() {\n        this.lives = App.sprite(\"heart\");\n        this.lives.anchor.set(0.5);\n        this.lives.x = this.config.livesIcon.x;\n        this.lives.y = this.config.livesIcon.y;\n        this.container.addChild(this.lives);\n    }\n\n    createCoinsText() {\n        this.coinsText = new PIXI.Text(this.player.coins.toString(), {fill: 0xffffff});\n        this.coinsText.x = this.config.coinsText.x;\n        this.coinsText.y = this.config.coinsText.y;\n        this.container.addChild(this.coinsText);\n    }\n    createLivesText() {\n        this.livesText = new PIXI.Text(this.player.lives.toString(), {fill: 0xffffff});\n        this.livesText.x = this.config.livesText.x;\n        this.livesText.y = this.config.livesText.y;\n        this.container.addChild(this.livesText);\n    }\n\n    create() {\n        this.createCoinsIcon();\n        this.createCoinsText();\n        this.createLivesIcon();\n        this.createLivesText();\n    }\n\n    update() {\n        this.coinsText.text = this.player.coins.toString();\n        this.livesText.text = this.player.lives.toString();\n    }\n}\n</code></pre> <p>A player object was passed to the <code>UI</code> class <code>constructor</code> and this way we can display the current values \u200b\u200bof <code>coins</code> and <code>lives</code> in the <code>update</code> method.</p> <p>Let's place UI in the upper left corner of the screen, setting values \u200b\u200bfor the position of all elements in the config:</p> <p><pre><code>export const Config = {\n    // ...\n    ui: {\n        coinsIcon: {\n            x: 50,\n            y: 40\n        },\n        coinsText: {\n            x: 90,\n            y: 30\n        },\n        livesIcon: {\n            x: 50,\n            y: 100\n        },\n        livesText: {\n            x: 90,\n            y: 90\n        }\n    },\n    player: {\n        coins: 200,\n        lives: 5\n    }\n};\n</code></pre> And finally, let's create an instance of <code>UI</code> in the <code>Game</code> class:</p> <pre><code>export class GameScene extends Scene {\n    create() {\n        // ...\n        this.createUI();\n    }\n\n    createUI() {\n        this.ui = new UI(this.player);\n        this.container.addChild(this.ui.container);\n    }\n    // ...\n}\n</code></pre>"},{"location":"tower-defense/#11-enemies-processing","title":"11. Enemies Processing","text":"<p>Units that were able to reach the last point on the path should take one life from the player and disappear from the game. Let's add a call to the <code>processCompletedEnemies</code> method at the beginning of the <code>update</code> method in the <code>Game</code> class:</p> <pre><code>    processCompletedEnemies() {\n        const enemy = this.enemies.units.find(enemy =&gt; enemy.isOutOfTheScreen);\n\n        if (enemy) {\n            enemy.remove();\n            --this.player.lives;\n            this.checkGameOver();\n        }\n    }\n    update() {\n        this.processCompletedEnemies();\n        // ...\n    }\n</code></pre> <p>Let's implement the <code>isOutOfTheScreen</code> getter:</p> <pre><code>    get isOutOfTheScreen() {\n        if (this.pathIndex === this.path.length) {\n            let point = this.sprite.getGlobalPosition();\n\n            if (point.x &lt; 0 ||point.x &gt; App.app.view.width) {\n                return true;\n            }\n        }\n\n\n        return false;\n    }\n</code></pre> <p>Here we make sure to check whether the enemy unit has reached its final point: <pre><code>this.pathIndex === this.path.length\n</code></pre></p> <p>And if the final point is reached, then it is enough to check the positions using one of the sprite coordinates.</p> <p>Let's add the <code>checkGameOver</code> method to the <code>Game</code> class. In it we will restart the game if the player has lost all lives: <pre><code>    checkGameOver() {\n        if (this.player.lives &lt;= 0) {\n            alert(\"Game Over!\");\n            App.scenes.start(\"Game\");\n        }\n    }\n</code></pre></p>"},{"location":"tower-defense/#12-earning-and-spending-coins","title":"12. Earning and spending coins","text":"<p>The player will spend coins to build and upgrade towers. And he will earn coins for killing each enemy. The cost of each tower, as well as the reward value for killing an enemy, are indicated in the <code>towers</code> and <code>enemies</code> configs in <code>Config.js</code>.</p> <p>Let's add processing of expenses and earnings to the corresponding methods of the <code>Game</code> class.</p> <ol> <li>Let's add an addditional check for the required number of coins and further spending for building and upgrading a tower in the <code>onTowerPlaceClick</code> method:</li> </ol> <pre><code>onTowerPlaceClick(towerPlace) {\n    const towerConfig = App.config.towers[\"tower\" + (towerPlace.level + 1)];\n\n    if (!towerConfig) {\n        return;\n    }\n\n    if (this.player.coins &lt; towerConfig.coins) {\n        return;\n    }\n\n    this.player.coins -= towerConfig.coins;\n    ++towerPlace.level;\n    // ...\n}\n</code></pre> <ol> <li>We will also give the player a reward for killing an enemy unit in the <code>processEnemyBulletCollision</code> method:</li> </ol> <pre><code>processEnemyBulletCollision() {\n    // ...\n    enemy.addDamage(bullet.damage);\n    if (enemy.hp &lt;= 0) {\n        this.player.coins += enemy.config.coins;\n    }\n    // ...\n}\n</code></pre> <p>Since our UI is already constantly updated in the <code>Game.update</code> method, we do not need to additionally redraw the UI for each such action.</p>"}]}